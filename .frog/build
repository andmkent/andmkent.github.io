((3) 0 () 6 ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2015-09-15-typesetting-with-plt-redex.md" . unix) (p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2015-07-06-stop-2015.md" . unix) (p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-03-24-racket-to-c-examples.md" . unix) (p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-12-20-let-aliasing-in-typed-racket.scrbl" . unix) (p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-11-10-quicksort-in-coq.scrbl" . unix) (p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-02-06-total-list-functions-in-coq.md" . unix)) () (h ! (equal) ((? . 0) f post (u . "Typesetting with PLT Redex") (? . 0) 1442514779 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2015/09/15/typesetting-with-plt-redex/index.html" . unix) "/blog/2015/09/15/typesetting-with-plt-redex/" (u . "2015-09-15T11:53:52") (? . 1) #f (c (u . "Racket")) (u . "\n<p><a href=\"http://redex.racket-lang.org/index.html\">PLT Redex</a> is a great tool for tinkering with and examining various aspects of programming languages. Although it can be used to <em>programmatically generate mathematical figures</em> for papers and the like (awesome!), the actual machinery for doing so is a little lower level than you want 99% of the time.</p>\n\n<p>To alleviate this, I developed a package (<a href=\"https://github.com/andmkent/typeset-rewriter\">typeset-rewriter</a>) with a few simple tools that make it much easier to build the rewriters redex natively supports.</p>") #t (u . "\n<p><a href=\"http://redex.racket-lang.org/index.html\">PLT Redex</a> is a great tool for tinkering with and examining various aspects of programming languages. Although it can be used to <em>programmatically generate mathematical figures</em> for papers and the like (awesome!), the actual machinery for doing so is a little lower level than you want 99% of the time.</p>\n\n<p>To alleviate this, I developed a package (<a href=\"https://github.com/andmkent/typeset-rewriter\">typeset-rewriter</a>) with a few simple tools that make it much easier to build the rewriters redex natively supports.</p>\n<!-- more-->\n\n<p>To demonstrate, let&rsquo;s take a simple redex model and look at typesetting it.</p>\n\n<h2 id=\"stlc-definition\">STLC Definition</h2>\n\n<p>First we define the language, like the simply typed lambda calculus:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"kn\">#lang </span><span class=\"nn\">racket</span>\n<span class=\"p\">(</span><span class=\"k\">require</span> <span class=\"n\">redex</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">define-language</span> <span class=\"n\">STLC</span>\n  <span class=\"p\">[</span><span class=\"n\">x</span>   <span class=\"n\">::=</span> <span class=\"n\">variable-not-otherwise-mentioned</span><span class=\"p\">]</span>\n  <span class=\"p\">[</span><span class=\"n\">v</span>   <span class=\"n\">::=</span> <span class=\"n\">integer</span> <span class=\"nb\">true</span> <span class=\"k\">false</span> <span class=\"nb\">add1</span> <span class=\"nb\">not</span> <span class=\"nb\">zero?</span><span class=\"p\">]</span>\n  <span class=\"p\">[</span><span class=\"nb\">exp</span> <span class=\"n\">::=</span> <span class=\"n\">x</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"n\">exp_1</span> <span class=\"n\">exp_2</span> <span class=\"n\">exp_3</span><span class=\"p\">)</span>\n           <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"n\">:</span> <span class=\"n\">ty</span><span class=\"p\">]</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">exp_1</span> <span class=\"n\">exp_2</span><span class=\"p\">)]</span>\n  <span class=\"p\">[</span><span class=\"n\">ty</span>  <span class=\"n\">::=</span> <span class=\"n\">int</span> <span class=\"n\">bool</span> <span class=\"p\">(</span><span class=\"n\">ty_1</span> <span class=\"k\">-&gt;</span> <span class=\"n\">ty_2</span><span class=\"p\">)]</span>\n  <span class=\"p\">[</span><span class=\"n\">Env</span> <span class=\"n\">::=</span> <span class=\"p\">([</span><span class=\"n\">x</span> <span class=\"n\">ty</span><span class=\"p\">]</span> <span class=\"k\">...</span><span class=\"p\">)])</span>\n</pre></div>\n\n</div>\n\n<p>Note: In this definition we <em>could</em> have used unicode characters directly (and then typesetting will use those same characters) but we shouldn&rsquo;t feel obligated to. We can throw in all the greek we want when typesetting.</p>\n\n<p>And maybe we have some judgments and metafunctions:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">define-judgment-form</span> <span class=\"n\">STLC</span>\n  <span class=\"kd\">#:mode</span> <span class=\"p\">(</span><span class=\"n\">typeof</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"n\">O</span><span class=\"p\">)</span>\n  <span class=\"kd\">#:contract</span> <span class=\"p\">(</span><span class=\"n\">typeof</span> <span class=\"n\">Env</span> <span class=\"nb\">exp</span> <span class=\"n\">ty</span><span class=\"p\">)</span>\n\n  <span class=\"p\">[</span><span class=\"n\">-----------------</span> <span class=\"s2\">\"T-Val\"</span>\n   <span class=\"p\">(</span><span class=\"n\">typeof</span> <span class=\"n\">Env</span> <span class=\"n\">v</span> <span class=\"p\">(</span><span class=\"n\">val-type</span> <span class=\"n\">v</span><span class=\"p\">))]</span>\n  \n  <span class=\"p\">[(</span><span class=\"n\">where</span> <span class=\"n\">ty</span> <span class=\"p\">(</span><span class=\"n\">lookup</span> <span class=\"n\">Env</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n   <span class=\"n\">----------</span> <span class=\"s2\">\"T-Var\"</span>\n   <span class=\"p\">(</span><span class=\"n\">typeof</span> <span class=\"n\">Env</span> <span class=\"n\">x</span> <span class=\"n\">ty</span><span class=\"p\">)]</span>\n\n  <span class=\"n\">....</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">define-metafunction</span> <span class=\"n\">STLC</span>\n  <span class=\"n\">val-type</span> <span class=\"n\">:</span> <span class=\"n\">v</span> <span class=\"k\">-&gt;</span> <span class=\"n\">ty</span>\n  <span class=\"n\">....</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">define-metafunction</span> <span class=\"n\">STLC</span>\n  <span class=\"n\">extend</span> <span class=\"n\">:</span> <span class=\"n\">Env</span> <span class=\"n\">x</span> <span class=\"n\">ty</span> <span class=\"k\">-&gt;</span> <span class=\"n\">Env</span>\n  <span class=\"n\">....</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">define-metafunction</span> <span class=\"n\">STLC</span>\n  <span class=\"n\">lookup</span> <span class=\"n\">:</span> <span class=\"n\">Env</span> <span class=\"n\">x</span> <span class=\"k\">-&gt;</span> <span class=\"n\">ty</span>\n  <span class=\"n\">....</span><span class=\"p\">)</span>\n</pre></div>\n\n</div>\n\n<p><em>\"&hellip;\" in this case is not special syntax, but just to stand in for the obvious definitions</em></p>\n\n<h2 id=\"vanilla-typesetting\">Vanilla Typesetting</h2>\n\n<p>If we were to try and typeset these definitions now, we probably wouldn&rsquo;t be too happy with the result:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">render-judgment-form</span> <span class=\"n\">typeof</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">with-rws</span> <span class=\"p\">(</span><span class=\"n\">render-language</span> <span class=\"n\">STLC</span> <span class=\"kd\">#:nts</span> <span class=\"o\">&#39;</span><span class=\"p\">(</span><span class=\"ss\">v</span> <span class=\"ss\">exp</span> <span class=\"ss\">ty</span> <span class=\"ss\">Env</span><span class=\"p\">)))</span>\n</pre></div>\n\n</div>\n\n<p>Sure, the figures will have the expected shape overall, but maybe we wanted the more traditional <code>Γ</code> for type environments instead of <code>Env</code>, and we probably want our typing judgments to look like <code>Γ ⊢ e : τ</code> instead of the default typesetting  <code>typeof〚Γ, e, τ〛</code>.</p>\n\n<h2 id=\"advanced-typesetting\">Advanced Typesetting</h2>\n\n<p>In addition to a few simple knobs and switches, PLT Redex model typesetting can be enhanced with two forms of rewriters.</p>\n\n<h3 id=\"atomic-rewriters\">Atomic rewriters</h3>\n\n<p><a href=\"http://docs.racket-lang.org/search/index.html?q=with-atomic-rewriter\">Atomic rewriters</a> will get us part of the way there. They allow us to rewrite symbols with provided strings (or thunks returning picts), and things like subscripts are preserved just the way we would hope:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">with-atomic-rewriter</span>\n <span class=\"o\">&#39;</span><span class=\"ss\">Env</span> <span class=\"s2\">\"Γ\"</span>\n <span class=\"p\">(</span><span class=\"n\">with-atomic-rewriter</span>\n  <span class=\"o\">&#39;</span><span class=\"ss\">t</span> <span class=\"o\">&#39;</span><span class=\"ss\">τ</span>\n  <span class=\"p\">(</span><span class=\"n\">render-language</span> <span class=\"n\">STLC</span> <span class=\"kd\">#:nts</span> <span class=\"o\">&#39;</span><span class=\"p\">(</span><span class=\"ss\">v</span> <span class=\"ss\">exp</span> <span class=\"ss\">ty</span> <span class=\"ss\">Env</span><span class=\"p\">))))</span>\n</pre></div>\n\n</div>\n\n<p>I&rsquo;m not sure why there isn&rsquo;t a plural version of this form&hellip; so I went ahead and defined one in the <code>typeset-rewriter</code> package:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">with-atomic-rws</span>\n <span class=\"p\">([</span><span class=\"o\">&#39;</span><span class=\"ss\">Env</span> <span class=\"s2\">\"Γ\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">exp</span> <span class=\"s2\">\"e\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">ty</span> <span class=\"s2\">\"τ\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">-&gt;</span> <span class=\"s2\">\"→\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">integer</span> <span class=\"s2\">\"n\"</span><span class=\"p\">])</span>\n <span class=\"p\">(</span><span class=\"n\">render-language</span> <span class=\"n\">STLC</span> <span class=\"kd\">#:nts</span> <span class=\"o\">&#39;</span><span class=\"p\">(</span><span class=\"ss\">v</span> <span class=\"ss\">exp</span> <span class=\"ss\">ty</span> <span class=\"ss\">Env</span><span class=\"p\">)))</span>\n</pre></div>\n\n</div>\n\n<p>But if we want to get our typing judgment to look correct, we&rsquo;re going to need just a little more muscle.</p>\n\n<h3 id=\"compound-rewriters\">Compound Rewriters</h3>\n\n<p>The hooks for <a href=\"http://docs.racket-lang.org/search/index.html?q=with-compound-rewriter\">compound rewriters</a> are pretty powerful. They allow us to transform arbitrary redex terms by letting us specify <em>compound rewriters</em> to be applied to parenthesized terms with a particular symbol at the head. So if we install a rewriter <code>lambda-rw</code> before typesetting</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">with-compound-rewriter</span>\n <span class=\"o\">&#39;</span><span class=\"ss\">lambda</span> <span class=\"n\">lambda-rw</span>\n <span class=\"p\">(</span><span class=\"n\">render-language</span> <span class=\"n\">STLC</span> <span class=\"kd\">#:nts</span> <span class=\"o\">&#39;</span><span class=\"p\">(</span><span class=\"ss\">v</span> <span class=\"ss\">exp</span> <span class=\"ss\">ty</span> <span class=\"ss\">Env</span><span class=\"p\">)))</span>\n</pre></div>\n\n</div>\n\n<p>any term of the form <code>(lambda any ...)</code> will be passed to our <code>lambda-rw</code> procedure.</p>\n\n<p>This gives us great power&hellip; but if we look at the signature for these rewriters we see theirs a subtle catch:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"nb\">listof</span> <span class=\"n\">lw</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"p\">(</span><span class=\"nb\">listof</span> <span class=\"p\">(</span><span class=\"nb\">or/c</span> <span class=\"n\">lw?</span> <span class=\"nb\">string?</span> <span class=\"n\">pict?</span><span class=\"p\">))</span>\n</pre></div>\n\n</div>\n\n<p>We have to work with lists of the <code>lw</code> structs that redex uses to typeset code if we want to tweak how our figures will look.</p>\n\n<p>To make this more palatable, I built a <code>match-lambda</code>-like macro that abstracts away all the struct details of our redex terms and lets us use the much simpler <code>quasiquote</code> and <code>unquote</code> syntax we&rsquo;re used to working with in Racket <a href=\"http://docs.racket-lang.org/reference/match.html\">pattern matching</a>.</p>\n\n<p>With these tools, we can define the following rewriters and rewriting context:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"k\">require</span> <span class=\"n\">typeset-rewriter</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">lambda-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">lambda</span> <span class=\"p\">([</span><span class=\"o\">,</span><span class=\"n\">x</span> <span class=\"ss\">:</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"o\">,</span><span class=\"n\">body</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"λ\"</span> <span class=\"n\">x</span> <span class=\"s2\">\":\"</span> <span class=\"n\">t</span> <span class=\"s2\">\". \"</span> <span class=\"n\">body</span><span class=\"p\">)]</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">lambda</span> <span class=\"p\">([</span><span class=\"o\">,</span><span class=\"n\">x</span> <span class=\"ss\">:</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"o\">,</span><span class=\"n\">body</span> <span class=\"o\">,</span><span class=\"n\">bodies</span> <span class=\"ss\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list*</span> <span class=\"s2\">\"λ\"</span> <span class=\"n\">x</span> <span class=\"s2\">\":\"</span> <span class=\"n\">t</span> <span class=\"s2\">\". (begin \"</span> <span class=\"n\">body</span> <span class=\"p\">(</span><span class=\"nb\">append</span> <span class=\"n\">bodies</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\")\"</span><span class=\"p\">)))]))</span>\n\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">typeof-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">typeof</span> <span class=\"o\">,</span><span class=\"n\">Γ</span> <span class=\"o\">,</span><span class=\"n\">e</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"\"</span> <span class=\"n\">Γ</span> <span class=\"s2\">\" ⊢ \"</span> <span class=\"n\">e</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">t</span><span class=\"p\">)]))</span>\n\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">extend-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">extend</span> <span class=\"o\">,</span><span class=\"n\">Γ</span> <span class=\"o\">,</span><span class=\"n\">x</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"\"</span> <span class=\"n\">Γ</span> <span class=\"s2\">\", \"</span> <span class=\"n\">x</span> <span class=\"s2\">\":\"</span> <span class=\"n\">t</span><span class=\"p\">)]))</span>\n\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">lookup-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">lookup</span> <span class=\"o\">,</span><span class=\"n\">Γ</span> <span class=\"o\">,</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"\"</span> <span class=\"n\">Γ</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">x</span> <span class=\"s2\">\")\"</span><span class=\"p\">)]))</span>\n\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">val-type-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">val-type</span> <span class=\"o\">,</span><span class=\"n\">v</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"type-of(\"</span> <span class=\"n\">v</span> <span class=\"s2\">\")\"</span><span class=\"p\">)]))</span>\n\n<span class=\"p\">(</span><span class=\"n\">define-rw-context</span> <span class=\"n\">with-stlc-rws</span>\n  <span class=\"kd\">#:atomic</span> <span class=\"p\">([</span><span class=\"o\">&#39;</span><span class=\"ss\">Env</span> <span class=\"s2\">\"Γ\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">exp</span> <span class=\"s2\">\"e\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">ty</span> <span class=\"s2\">\"τ\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">-&gt;</span> <span class=\"s2\">\"→\"</span><span class=\"p\">]</span> <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">integer</span> <span class=\"s2\">\"n\"</span><span class=\"p\">])</span>\n  <span class=\"kd\">#:compound</span> <span class=\"p\">([</span><span class=\"o\">&#39;</span><span class=\"ss\">lambda</span> <span class=\"n\">lambda-rw</span><span class=\"p\">]</span>\n              <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">typeof</span> <span class=\"n\">typeof-rw</span><span class=\"p\">]</span>\n              <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">extend</span> <span class=\"n\">extend-rw</span><span class=\"p\">]</span>\n              <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">lookup</span> <span class=\"n\">lookup-rw</span><span class=\"p\">]</span>\n              <span class=\"p\">[</span><span class=\"o\">&#39;</span><span class=\"ss\">val-type</span> <span class=\"n\">val-type-rw</span><span class=\"p\">]))</span>\n</pre></div>\n\n</div>\n\n<p>This allows us to produce figures looking just the way we want:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">with-stlc-rws</span> <span class=\"p\">(</span><span class=\"n\">render-language</span> <span class=\"n\">STLC</span> <span class=\"kd\">#:nts</span> <span class=\"o\">&#39;</span><span class=\"p\">(</span><span class=\"ss\">v</span> <span class=\"ss\">exp</span> <span class=\"ss\">ty</span> <span class=\"ss\">Env</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"n\">with-stlc-rws</span> <span class=\"p\">(</span><span class=\"n\">render-judgment-form</span> <span class=\"n\">typeof</span><span class=\"p\">))</span>\n</pre></div>\n\n</div>\n\n<div class=\"figure\"><img src=\"/img/pltredexstlc.png\" alt=\"\" />\n <p class=\"caption\"></p></div>\n\n<h2 id=\"further-customizations\">Further Customizations</h2>\n\n<p>You may have noticed I used a more complex definition for <code>lambda-rw</code> than seemed necessary:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">lambda-rw</span>\n  <span class=\"p\">(</span><span class=\"n\">rw-lambda</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">lambda</span> <span class=\"p\">([</span><span class=\"o\">,</span><span class=\"n\">x</span> <span class=\"ss\">:</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"o\">,</span><span class=\"n\">body</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\"λ\"</span> <span class=\"n\">x</span> <span class=\"s2\">\":\"</span> <span class=\"n\">t</span> <span class=\"s2\">\". \"</span> <span class=\"n\">body</span><span class=\"p\">)]</span>\n   <span class=\"p\">[</span><span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">lambda</span> <span class=\"p\">([</span><span class=\"o\">,</span><span class=\"n\">x</span> <span class=\"ss\">:</span> <span class=\"o\">,</span><span class=\"n\">t</span><span class=\"p\">])</span> <span class=\"o\">,</span><span class=\"n\">body</span> <span class=\"o\">,</span><span class=\"n\">bodies</span> <span class=\"ss\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"nb\">list*</span> <span class=\"s2\">\"λ\"</span> <span class=\"n\">x</span> <span class=\"s2\">\":\"</span> <span class=\"n\">t</span> <span class=\"s2\">\". (begin \"</span> <span class=\"n\">body</span> <span class=\"p\">(</span><span class=\"nb\">append</span> <span class=\"n\">bodies</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"s2\">\")\"</span><span class=\"p\">)))]))</span>\n</pre></div>\n\n</div>\n\n<p>This was just to show that the <code>rw</code> macro is merely a thin layer of syntax that expands into Racket&rsquo;s powerful <code>match</code> form. Anything following an <code>unquote</code> (<em>e.g. a <code>,</code></em>) in the <code>quasiquote</code> pattern can be an arbitrary match pattern, and things like elipses&mdash;since they are supported by <code>match</code>&mdash;are supported as well.</p>\n\n<h2 id=\"installing-and-using-typeset-rewriter\">Installing and using <code>typeset-rewriter</code></h2>\n\n<p>From the command line, enter</p>\n\n<p><code>raco pkg install typeset-rewriter</code></p>\n\n<p>Or from within DrRacket, open the Package Manager (<code>File&gt;Package Manager</code> on Mac), enter <code>typeset-rewriter</code> in the <code>Package Source</code> field and install.</p>\n\n<p>After installation, simply add <code>typeset-rewriter</code> to the list of required packages in your module. Ex <code>(require redex\ntypeset-rewriter)</code>.</p>\n\n<br />")) ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2015-07-06-stop-2015.md" . unix) f post (u . "STOP 2015 Talk: Adding Practical Dependent Types to Typed Racket") (? . 1) 1442454548 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2015/07/06/stop-2015-talk-adding-practical-dependent-types-to-typed-racket/index.html" . unix) "/blog/2015/07/06/stop-2015-talk-adding-practical-dependent-types-to-typed-racket/" (u . "2015-07-06T09:16:07") (? . 3) (? . 0) (c (u . "Talks") c (u . "Typed Racket")) (u . "\n<p>At the <a href=\"http://2015.ecoop.org/track/STOP2015\">Scripts to Programs 2015</a> workshop (co-located with ECOOP 2015) I gave a talk reporting on our upcoming addition of some basic dependent types to Typed Racket.</p>") #t (u . "\n<p>At the <a href=\"http://2015.ecoop.org/track/STOP2015\">Scripts to Programs 2015</a> workshop (co-located with ECOOP 2015) I gave a talk reporting on our upcoming addition of some basic dependent types to Typed Racket.</p>\n<!-- more-->\n\n<h2 id=\"abstract\">Abstract</h2>\n\n<p>Typed Racket is a statically typed dialect of Racket that allows idiomatic Racket programs to be enriched with types. It can reason about many dynamically typed programming patterns while providing sound interoperability and optimizations. We have designed and are implementing an extension to Typed Racket which adds support for logical refinement types and linear integer constraints. This summary discusses our approach to implementing this novel combination of precise specifications and optimizations while maintaining sound interoperability with dynamically typed code. A PLT Redex model of the basic calculus describing our extension can be seen at https://github.com/andmkent/stop2015-redex and our development fork where we are extending Typed Racket is available at https://github.com/andmkent/typed-racket/tree/dtr-prototype.</p>\n\n<h2 id=\"overview-of-additions-to-typed-racket\">Overview of Additions to Typed Racket</h2>\n\n<p>This extension involves adding just a few simple forms to Typed Racket.</p>\n\n<p>First, we need to add a type which can express dependencies within it. We do this with refinement types:</p>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"n\">:</span> <span class=\"n\">T</span><span class=\"p\">]</span> <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n</pre></div>\n\n</div>\n\n<p>This intuitively describes all values <code>x</code> of type <code>T</code> where proposition <code>P(x)</code> holds.</p>\n\n<p>Today Typed Racket <em>already</em> reasons about some basic propositions:</p>\n\n<ul>\n <li>\n  <p><code>(x -: T)</code>, <code>x</code> is of type <code>T</code></p></li>\n <li>\n  <p><code>(x -! T)</code>, <code>x</code> is not of type <code>T</code></p></li>\n <li>\n  <p><code>(and P ...)</code>, standard logical <em>and</em></p></li>\n <li>\n  <p><code>(or P ...)</code>, standard logical <em>or</em></p></li></ul>\n\n<p>This is how Typed Racket can typecheck programs using type-tests in <code>if</code> statements, etc&hellip;</p>\n\n<p>Next we add propositions which can talk about linear inequalities:</p>\n\n<ul>\n <li><code>((+ x (* 3 y)) ≤ 42)</code>, the linear combination <code>(+ x (* 3 y))</code> is less than or equal to <code>42</code>.</li></ul>\n\n<p>These propositions can only reference linear combinations of integers (<em>e.g. no 1.5 or (* x y)</em>).</p>\n\n<h2 id=\"examples-with-refinements-and-dependent-types\">Examples with Refinements and Dependent Types</h2>\n\n<p>Here are two examples of programs we can write with these new forms. Both utilize <code>safe-vector-</code> operations, whose type requires the index to be verified statically (and they can therefore omit the runtime bounds-check).</p>\n\n<h3 id=\"vector-dot-product\">Vector Dot Product</h3>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"n\">:</span> <span class=\"n\">dot-prod</span> <span class=\"p\">(</span><span class=\"n\">~&gt;</span> <span class=\"p\">[</span><span class=\"n\">A</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vecof</span> <span class=\"n\">Int</span><span class=\"p\">)]</span>\n                <span class=\"p\">[</span><span class=\"n\">B</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">v</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vecof</span> <span class=\"n\">Int</span><span class=\"p\">)]</span>\n                             <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">A</span><span class=\"p\">)))]</span>\n                <span class=\"n\">Int</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"p\">(</span><span class=\"n\">dot-prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">for/sum</span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"p\">(</span><span class=\"nb\">in-range</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">A</span><span class=\"p\">))])</span>\n    <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"p\">(</span><span class=\"n\">safe-vector-ref</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"n\">safe-vector-ref</span> <span class=\"n\">B</span> <span class=\"n\">i</span><span class=\"p\">))))</span>\n</pre></div>\n\n</div>\n\n<h3 id=\"matrix-multiplication\">Matrix Multiplication</h3>\n\n<div class=\"brush: racket\">\n <div class=\"source\">\n  <pre><span class=\"p\">(</span><span class=\"k\">define-syntax-rule</span> <span class=\"p\">(</span><span class=\"n\">Mref</span> <span class=\"n\">M</span> <span class=\"n\">r</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"n\">safe-vector-ref</span> <span class=\"p\">(</span><span class=\"n\">safe-vector-ref</span> <span class=\"n\">M</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"n\">c</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"k\">define-syntax-rule</span> <span class=\"p\">(</span><span class=\"n\">Mset!</span> <span class=\"n\">M</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"n\">safe-vector-set!</span> <span class=\"p\">(</span><span class=\"n\">safe-vector-ref</span> <span class=\"n\">M</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"n\">c</span> <span class=\"n\">val</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; A[m×n] * B[n×p] = C[m×p]) </span>\n<span class=\"p\">(</span><span class=\"n\">:</span> <span class=\"n\">matrix*</span>\n   <span class=\"p\">(</span><span class=\"n\">~&gt;</span> <span class=\"p\">[</span><span class=\"n\">A</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">a</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"n\">Int</span><span class=\"p\">)]</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"n\">n</span><span class=\"p\">)))]</span>\n       <span class=\"p\">[</span><span class=\"n\">B</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">b</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"n\">Int</span><span class=\"p\">)]</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">)))]</span>\n       <span class=\"p\">[</span><span class=\"n\">C</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">c</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Vec</span> <span class=\"n\">Int</span><span class=\"p\">)]</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"n\">p</span><span class=\"p\">)))]</span>\n       <span class=\"p\">[</span><span class=\"n\">m</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">A</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">C</span><span class=\"p\">)))]</span>\n       <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">y</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"n\">y</span> <span class=\"p\">(</span><span class=\"n\">len</span> <span class=\"n\">B</span><span class=\"p\">)))]</span>\n       <span class=\"p\">[</span><span class=\"n\">p</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span>\n       <span class=\"n\">Void</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"p\">(</span><span class=\"n\">matrix*</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">for*</span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"n\">x</span> <span class=\"n\">m</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">in-range</span> <span class=\"n\">m</span><span class=\"p\">)]</span>\n         <span class=\"p\">[</span><span class=\"n\">j</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">y</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">in-range</span> <span class=\"n\">p</span><span class=\"p\">)])</span>\n    <span class=\"p\">(</span><span class=\"k\">define</span> <span class=\"n\">Cij-val</span> <span class=\"n\">:</span> <span class=\"n\">Int</span>\n      <span class=\"p\">(</span><span class=\"k\">for/sum</span> <span class=\"p\">([</span><span class=\"n\">k</span> <span class=\"n\">:</span> <span class=\"p\">(</span><span class=\"n\">Refine</span> <span class=\"p\">[</span><span class=\"n\">z</span> <span class=\"n\">:</span> <span class=\"n\">Nat</span><span class=\"p\">]</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"n\">z</span> <span class=\"n\">n</span><span class=\"p\">))</span>\n                   <span class=\"p\">(</span><span class=\"nb\">in-range</span> <span class=\"n\">n</span><span class=\"p\">)])</span>\n        <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"n\">Mref</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">Mref</span> <span class=\"n\">B</span> <span class=\"n\">k</span> <span class=\"n\">j</span><span class=\"p\">))))</span>\n    <span class=\"p\">(</span><span class=\"n\">Mset!</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">Cij-val</span><span class=\"p\">)))</span>\n</pre></div>\n\n</div>\n\n<h2 id=\"vector-bounds-case-study\">Vector Bounds Case Study</h2>\n\n<p>We performed a case study analyzing how many instances of <code>vector-ref</code> and <code>vector-set!</code> we could automatically verify without any modifications to the code. In approximately 57k lines of code drawn from Racket&rsquo;s <a href=\"http://docs.racket-lang.org/math/\">math</a>, <a href=\"http://docs.racket-lang.org/plot/index.html?q=plot\">plot</a>, and <a href=\"https://github.com/ntoronto/pict3d\">pict3d</a> libraries we successfully could verify the vector operations about 50% of the time.</p>\n\n<p>We will report in more detail on these findings in an upcoming publication.</p>")) ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-02-06-total-list-functions-in-coq.md" . unix) f post (u . "Total List Functions") (? . 5) 1442277667 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2014/02/06/total-list-functions/index.html" . unix) "/blog/2014/02/06/total-list-functions/" (u . "2014-02-06T22:36:50") #f (? . 2) (c (u . "Coq") c (u . "Dependent Types")) (u . "\n<p>What is the type of a function which returns the first element of a list? One possible (and likely common) answer would be:</p>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))\" style=\"color: inherit\">:</a></span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))\" style=\"color: inherit\">first</a></span> <span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.All))\" style=\"color: inherit\">All</a></span> <span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"p\">((</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Listof))\" style=\"color: inherit\">Listof</a></span> <span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))\" style=\"color: inherit\">-&gt;</a></span> <span class=\"n\">X</span><span class=\"p\">)))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>This (typed racket syntax) says <em>first</em> is a function from a list of X&rsquo;s to an X (where X is any type). However, we really know that, although its type is ((Listof X) -&gt; X), if we pass an empty list of X we will not get an X, but a runtime error of some sort (e.g. no values). The type then isn&rsquo;t really giving us a guarantee of what it will do for us&hellip; it&rsquo;s just telling us what it will <em>try</em> to do for us if it doesn&rsquo;t fail.</p>\n\n<p><em>&ldquo;No. Try not. Do&hellip; or do not. There is no try.&rdquo; - Master Yoda</em></p>\n\n<p>There is a parallel in math: some functions are not defined for all possible input values (e.g. f(x)=1/x). These are called partial functions (as opposed to total functions). It is common practice to reserve the term &ldquo;function&rdquo; for total functions in math, while in programming partial functions are ubiquitous and there is little effort to distinguish between the two. If only there was some way that the types could reflect this possibility&hellip;</p>") #t (u . "\n<p>What is the type of a function which returns the first element of a list? One possible (and likely common) answer would be:</p>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))\" style=\"color: inherit\">:</a></span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))\" style=\"color: inherit\">first</a></span> <span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.All))\" style=\"color: inherit\">All</a></span> <span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"p\">((</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Listof))\" style=\"color: inherit\">Listof</a></span> <span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))\" style=\"color: inherit\">-&gt;</a></span> <span class=\"n\">X</span><span class=\"p\">)))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>This (typed racket syntax) says <em>first</em> is a function from a list of X&rsquo;s to an X (where X is any type). However, we really know that, although its type is ((Listof X) -&gt; X), if we pass an empty list of X we will not get an X, but a runtime error of some sort (e.g. no values). The type then isn&rsquo;t really giving us a guarantee of what it will do for us&hellip; it&rsquo;s just telling us what it will <em>try</em> to do for us if it doesn&rsquo;t fail.</p>\n\n<p><em>&ldquo;No. Try not. Do&hellip; or do not. There is no try.&rdquo; - Master Yoda</em></p>\n\n<p>There is a parallel in math: some functions are not defined for all possible input values (e.g. f(x)=1/x). These are called partial functions (as opposed to total functions). It is common practice to reserve the term &ldquo;function&rdquo; for total functions in math, while in programming partial functions are ubiquitous and there is little effort to distinguish between the two. If only there was some way that the types could reflect this possibility&hellip;</p>\n<!-- more-->\n\n<p><em>Note: The property of being total in theoretical computer science is also referred to as the strong normalization property.</em></p>\n\n<p>In type theory, the type that has no values is commonly called the <a href=\"http://en.wikipedia.org/wiki/Bottom_type\">bottom type</a>. It is often written as ⊥ (\\bot in LaTeX). Thus we could say <em>first</em> has type ((Listof X) -&gt; (U X ⊥)), or in other words, we define our return type as the union of types X and ⊥ to reflect that not returning anything (the bottom type ⊥) is an option.</p>\n\n<p>Type systems often dodge/ignore this problem by merely guaranteeing that they will prevent all <em>type errors</em> and not <em>run-time errors</em>, with a definition of <em>type errors</em> that to them is reasonable and suites their needs. Lets assume, however, that we did not wish to ignore ⊥ and that we wanted our type checking to provide stronger guarantees about what happens in our program. We could approach this by using a type with an explicit failure case for <em>first</em> (i.e. wrap the return value in a &ldquo;maybe&rdquo;), thus forcing us to always return a failure value (or similar) instead of error or exit. The other option (and the one we will explore) is to use types which limit the domain of the function so that the function <em>becomes</em> total (e.g. dissallow empty lists in the type itself so first <em>always</em> returns an X).</p>\n\n<h2 id=\"sigma-types\">Sigma Types</h2>\n\n<p>In a previous post while examining what a verified version of quicksort might look like, I included the properties I desired <em>in</em> the return type:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">Program</span> <span class=\"kn\">Fixpoint</span> <span class=\"n\">quicksort</span>\n        <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n        <span class=\"o\">{</span><span class=\"n\">sl</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span> <span class=\"o\">|</span> <span class=\"nc\">Permutation</span> <span class=\"n\">l</span> <span class=\"n\">sl</span>\n                         <span class=\"o\">/\\</span> <span class=\"nc\">StronglySorted</span> <span class=\"n\">le</span> <span class=\"n\">sl</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>That is, the return type of this function is not merely a list, but a list and a proof it is a permutation of the input and strongly sorted. This was done using Coq&rsquo;s Sigma-types:</p>\n\n<p>From the Coq manual: <em>Subsets and Sigma-types (sig A P), or more suggestively {x:A | P x}, denotes the subset of elements of the type A which satisfy the predicate P.</em></p>\n\n<p>Similarly, Sigma-types can help us in our endeavor to devise robust, total list functions.</p>\n\n<h2 id=\"writing-a-total-first\">Writing a total &ldquo;first&rdquo;</h2>\n\n<p>What we really want to do is say that our function &ldquo;first&rdquo; is not merely of type ((Listof X) -&gt; X), but it additionally requires the input list be non-empty and it returns the first element of it.</p>\n\n<p>Now we can attempt write our total version of first:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Definition</span> <span class=\"n\">strong_first</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span><span class=\"o\">):</span> <span class=\"nc\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">reflneq</span> <span class=\"n\">pf</span> <span class=\"k\">with</span> <span class=\"k\">end</span>\n  <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span>  <span class=\"n\">x</span>\n<span class=\"k\">end</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>strong_first takes a list l and a proof it is not null and returns an X.</p>\n\n<p>It accomplishes this by matching the list against the possible two structural forms for a list:</p>\n\n<p><em>nil case</em>: If it is empty, we use the proof that nil &lt;&gt; nil with the following lemma:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Lemma</span> <span class=\"n\">reflneq</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"nn\">False</span><span class=\"p\">.</span>\n<span class=\"nn\">Proof</span><span class=\"p\">.</span>\n  <span class=\"n\">auto</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>This gives us False within our function, which we use to vacuously satisfy the match statement for the nil case (since False has exactly 0 constructors).</p>\n\n<p><em>cons case</em>: In the cons case, we merely return the first element, x.</p>\n\n<p>If we were designing a complex system that used this function, if/when we extracted the code out of Coq into another language (OCaml in this case) we get:</p>\n\n<div class=\"brush: ocaml\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"k\">let</span> <span class=\"n\">strong_first</span> <span class=\"o\">=</span> <span class=\"k\">function</span>\n<span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> <span class=\"k\">assert</span> <span class=\"bp\">false</span> <span class=\"c\">(* absurd case *)</span>\n<span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>And although this function <em>seems</em> to have the problem we originally sought to solve (it errors on some input allowed by the OCaml type system), this case would <em>never</em> be reached by any code also verified and extracted in Coq (since the type checking in Coq would have <em>ensured</em> the list was non-empty). As for whether or not external code calls this function incorrectly (i.e. with an empty list), that is a matter that must be handled separately. One approach would be the way Typed Racket ensures that typed and untyped modules play nicely: it wraps interactions between untyped and typed code in contracts that perform dynamic checks to prevent any such &ldquo;mixed type error.&rdquo;</p>\n\n<h2 id=\"a-verified-return-value\">A verified return value</h2>\n\n<p>We can also, as we did with quicksort, add a specification to the return type via a Sigma-type so our specification is more precise.</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Definition</span> <span class=\"n\">strong_first&#39;</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span><span class=\"o\">):</span>\n<span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"nc\">X</span><span class=\"o\">|</span> <span class=\"k\">exists</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">reflneq</span> <span class=\"n\">pf</span> <span class=\"k\">with</span> <span class=\"k\">end</span>\n  <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"n\">x</span>\n<span class=\"k\">end</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Unfortunately, as we see when we try to compile this, we are now returning only the element and not the proof of it&rsquo;s first-ness:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">The</span> <span class=\"n\">term</span> <span class=\"s2\">\"x\"</span> <span class=\"n\">has</span> <span class=\"n\">type</span> <span class=\"s2\">\"X\"</span> <span class=\"n\">while</span> <span class=\"n\">it</span> <span class=\"k\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n<span class=\"o\">{</span><span class=\"n\">x0</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"k\">exists</span> <span class=\"n\">xs0</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">,</span> <span class=\"o\">?</span><span class=\"mi\">25</span> <span class=\"o\">=</span> <span class=\"n\">x0</span> <span class=\"o\">::</span> <span class=\"n\">xs0</span><span class=\"o\">}</span><span class=\"s2\">\"</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>We will take this as an opportunity to exploit the ability to change perspectives and instead approach this in Coq&rsquo;s interactive proving mode:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Definition</span> <span class=\"n\">strong_first&#39;</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kn\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"k\">exists</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">}.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>This creates a proof goal that matches the signature of the function we wish to write:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre> <span class=\"nc\">X</span> <span class=\"o\">:</span> <span class=\"kn\">Set</span>\n<span class=\"o\">============================</span>\n <span class=\"k\">forall</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span> <span class=\"o\">-&gt;</span>\n   <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"k\">exists</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">}</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>We can then use the refine tactic:</p>\n\n<p><em>8.2.3 refine term: This tactic applies to any goal. It behaves like exact with a big difference: the user can leave some holes (denoted by</em> or (<em>:type)) in the term. refine will generate as many subgoals as there are holes in the term. The type of holes must be either synthesized by the system or declared by an explicit cast like (</em>:nat-&gt;Prop). This low-level tactic can be useful to advanced users._</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre>  <span class=\"k\">refine</span>\n<span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">pf</span> <span class=\"o\">=&gt;</span>\n   <span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n     <span class=\"o\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">False_rec</span> <span class=\"o\">_</span> <span class=\"o\">_</span>\n     <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"n\">exist</span> <span class=\"o\">_</span> <span class=\"n\">x</span> <span class=\"o\">_</span>\n   <span class=\"k\">end</span><span class=\"o\">).</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p><em>Note: We used False_rec instead of the empty match cases we did previously. They&rsquo;re really the same thing when you flesh them all the way out.</em></p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">False_rec</span>\n<span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"nc\">P</span> <span class=\"o\">:</span> <span class=\"kn\">Set</span><span class=\"o\">,</span> <span class=\"nc\">False</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">P</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>False_rec just hides some of the machinery and the _ wholes allow us to give Coq&rsquo;s automation a chance to fill in the gaps for us.</p>\n\n<p>This is what remains in our goals:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"mi\">2</span> <span class=\"n\">subgoals</span><span class=\"o\">,</span> <span class=\"n\">subgoal</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"nc\">ID</span> <span class=\"mi\">41</span><span class=\"o\">)</span>\n\n  <span class=\"nc\">X</span> <span class=\"o\">:</span> <span class=\"kn\">Set</span>\n  <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span>\n  <span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"n\">pf0</span> <span class=\"o\">:</span> <span class=\"n\">nil</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"o\">============================</span>\n   <span class=\"nc\">False</span>\n\n<span class=\"n\">subgoal</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"nc\">ID</span> <span class=\"mi\">45</span><span class=\"o\">)</span> <span class=\"k\">is</span><span class=\"o\">:</span>\n <span class=\"k\">exists</span> <span class=\"n\">xs0</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs0</span>\n\n<span class=\"nn\">Abort</span><span class=\"p\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>From here we can see the resulting goals are relatively simple, and so we can supplement the refine with a call to eauto. We will also define and use some notation which can be useful if writing numerous functions in this fashion:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Notation</span> <span class=\"s2\">\"&gt;&gt;&lt;&lt;\"</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"nc\">False_rec</span> <span class=\"o\">_</span> <span class=\"o\">_).</span>\n<span class=\"kn\">Notation</span> <span class=\"s2\">\"&gt;&gt; x &lt;&lt;\"</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"nc\">False_rec</span> <span class=\"o\">_</span> <span class=\"n\">x</span><span class=\"o\">).</span>\n<span class=\"kn\">Notation</span> <span class=\"s2\">\"[ e ]\"</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exist</span> <span class=\"o\">_</span> <span class=\"n\">e</span> <span class=\"o\">_).</span>\n\n<span class=\"kn\">Definition</span> <span class=\"n\">strong_first&#39;</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kn\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"n\">l</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">nil</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"k\">exists</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">}.</span>\n  <span class=\"k\">refine</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">pf</span> <span class=\"o\">=&gt;</span>\n       <span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n         <span class=\"o\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">&gt;&gt;&lt;&lt;</span>\n         <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n       <span class=\"k\">end</span><span class=\"o\">);</span> <span class=\"n\">eauto</span><span class=\"o\">.</span>\n<span class=\"kn\">Defined</span><span class=\"o\">.</span>\n\n<span class=\"nc\">Extraction</span> <span class=\"n\">strong_first&#39;</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>It&rsquo;s the same extracted function, and it now has the specified output! Cool.</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c\">(** val strong_first&#39; : &#39;a1 list -&gt; &#39;a1 **)</span>\n\n<span class=\"k\">let</span> <span class=\"n\">strong_first&#39;</span> <span class=\"o\">=</span> <span class=\"n\">function</span>\n  <span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> <span class=\"k\">assert</span> <span class=\"bp\">false</span> <span class=\"c\">(* absurd case *)</span>\n  <span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Now let&rsquo;s see if we can apply this strategy to devise a verified list-indexing function!</p>\n\n<h2 id=\"verified-list-indexing\">Verified List-Indexing</h2>\n\n<p>First we define a lemma or two that will be used in our definition:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Lemma</span> <span class=\"n\">lt_list</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"nc\">S</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span>\n<span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">xs</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"n\">crush</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Lemma</span> <span class=\"n\">ltnil</span> <span class=\"o\">(</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"k\">forall</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">nil</span> <span class=\"o\">-&gt;</span> <span class=\"nn\">False</span><span class=\"p\">.</span>\n<span class=\"nn\">Proof</span><span class=\"p\">.</span>\n  <span class=\"n\">crush</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Note: I wrote these as I saw I needed them, obviously. By &ldquo;first&rdquo;, I mean we need these defined first =)</p>\n\n<p>We also define a notion which can capture the idea we have for what it means to return the correct nth item from a list:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Inductive</span> <span class=\"nc\">ListIndex</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kn\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">X</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"nc\">LInil</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"nc\">ListIndex</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"o\">|</span> <span class=\"nc\">LIcons</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">n</span> <span class=\"n\">x&#39;</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n             <span class=\"nc\">ListIndex</span> <span class=\"n\">n</span> <span class=\"n\">x&#39;</span> <span class=\"n\">xs</span> <span class=\"o\">-&gt;</span>\n             <span class=\"nc\">ListIndex</span> <span class=\"o\">(</span><span class=\"nc\">S</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x&#39;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">).</span>\n<span class=\"kn\">Hint</span> <span class=\"nc\">Constructors</span> <span class=\"nn\">ListIndex</span><span class=\"p\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>And for convenience&hellip; I define a shorter, more clear name for the function that extracts the item out of a sigma type:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Definition</span> <span class=\"n\">sigX</span> <span class=\"o\">:=</span> <span class=\"n\">proj1_sig</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Definition</span> <span class=\"n\">strong_nth</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kn\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}.</span>\n  <span class=\"k\">refine</span>\n    <span class=\"o\">(</span><span class=\"k\">fix</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n       <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n       <span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n         <span class=\"o\">|</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n         <span class=\"o\">|</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"nc\">S</span> <span class=\"n\">i&#39;</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span>  <span class=\"o\">[</span><span class=\"n\">sigX</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"n\">i&#39;</span> <span class=\"o\">(</span><span class=\"n\">lt_list</span> <span class=\"n\">pf</span><span class=\"o\">))]</span>\n         <span class=\"o\">|</span> <span class=\"o\">_,</span> <span class=\"o\">_,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">&gt;&gt;</span><span class=\"n\">ltnil</span> <span class=\"n\">pf</span><span class=\"o\">&lt;&lt;</span>\n       <span class=\"k\">end</span><span class=\"o\">);</span> <span class=\"n\">crush</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>We&rsquo;re almost there. The crush tactic derived everything except the details regarding the fact that our recursive call&rsquo;s type is equivalent to (or implies, perhaps) the type we wish to return from the initial call:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre> <span class=\"nc\">X</span> <span class=\"o\">:</span> <span class=\"kn\">Set</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n      <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}</span>\n  <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n  <span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span>\n  <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span>\n  <span class=\"n\">pf0</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nc\">S</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"n\">i&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n  <span class=\"n\">pf1</span> <span class=\"o\">:</span> <span class=\"nc\">S</span> <span class=\"n\">i&#39;</span> <span class=\"o\">&lt;</span> <span class=\"nc\">S</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"o\">============================</span>\n   <span class=\"nc\">ListIndex</span> <span class=\"o\">(</span><span class=\"nc\">S</span> <span class=\"n\">i&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sigX</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"n\">i&#39;</span> <span class=\"o\">(</span><span class=\"n\">lt_list</span> <span class=\"n\">pf1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"nn\">Abort</span><span class=\"p\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>We simply build a lemma that extends the proof to meet our needs, given what we get from the recursive call and we&rsquo;re good to go:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Lemma</span> <span class=\"n\">nthrec</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span> <span class=\"kn\">Set</span><span class=\"o\">}:</span> <span class=\"k\">forall</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}),</span>\n<span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span>\n<span class=\"nc\">ListIndex</span> <span class=\"o\">(</span><span class=\"nc\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">proj1_sig</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span><span class=\"o\">.</span>\n  <span class=\"k\">destruct</span> <span class=\"n\">x</span><span class=\"o\">.</span> <span class=\"n\">crush</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n<span class=\"kn\">Hint</span> <span class=\"kn\">Resolve</span> <span class=\"n\">nthrec</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Definition</span> <span class=\"n\">strong_nth</span> <span class=\"o\">{</span><span class=\"nc\">X</span><span class=\"o\">:</span><span class=\"kn\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}.</span>\n  <span class=\"k\">refine</span>\n    <span class=\"o\">(</span><span class=\"k\">fix</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"nc\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pf</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n       <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"nc\">X</span> <span class=\"o\">|</span> <span class=\"nc\">ListIndex</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n       <span class=\"k\">match</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"k\">with</span>\n         <span class=\"o\">|</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n         <span class=\"o\">|</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"nc\">S</span> <span class=\"n\">i&#39;</span><span class=\"o\">,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span>  <span class=\"o\">[</span><span class=\"n\">sigX</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"n\">i&#39;</span> <span class=\"o\">(</span><span class=\"n\">lt_list</span> <span class=\"n\">pf</span><span class=\"o\">))]</span>\n         <span class=\"o\">|</span> <span class=\"o\">_,</span> <span class=\"o\">_,</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"o\">&gt;&gt;</span><span class=\"n\">ltnil</span> <span class=\"n\">pf</span><span class=\"o\">&lt;&lt;</span>\n       <span class=\"k\">end</span><span class=\"o\">);</span> <span class=\"n\">crush</span><span class=\"o\">.</span>\n<span class=\"kn\">Defined</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>So how is this different from our first example (first)?</p>\n\n<p>I had to explicitly tell it I wanted to derive false from the lemma ltnil. Without that it would &ldquo;complete&rdquo;, but the result would be ill-typed and fail when closing the proof with &ldquo;Defined&rdquo;. Can&rsquo;t leave everything up to automation I guess =) Because of the recursive nature of this function, I had to build a lemma which evaluated the Sigma-type of the recursive call and showed from it we could derive the type we wished to ultimately return.</p>\n\n<p>And here&rsquo;s what she looks like extracted:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8\n9</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c\">(** val strong_nth : &#39;a1 list -&gt; nat -&gt; &#39;a1 **)</span>\n\n<span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">strong_nth</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"o\">=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"nc\">Nil</span> <span class=\"o\">-&gt;</span> <span class=\"k\">assert</span> <span class=\"bp\">false</span> <span class=\"c\">(* absurd case *)</span>\n  <span class=\"o\">|</span> <span class=\"nc\">Cons</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n     <span class=\"o\">|</span> <span class=\"nc\">O</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span>\n     <span class=\"o\">|</span> <span class=\"nc\">S</span> <span class=\"n\">i&#39;</span> <span class=\"o\">-&gt;</span> <span class=\"n\">sigX</span> <span class=\"o\">(</span><span class=\"n\">strong_nth</span> <span class=\"n\">xs</span> <span class=\"n\">i&#39;</span><span class=\"o\">))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Beautiful!</p>\n\n<p>Source code related to this post found <a href=\"https://github.com/sgtamk/sgtamk.github.io/blob/master/snippets/20140206-listbasics-code.v\">here</a>.</p>\n\n<p>Note: This post is inspired by some of my personal experimenting and some related material from the &ldquo;Subset&rdquo; chapter from <a href=\"http://adam.chlipala.net/cpdt/\">CPDT</a> (an excellent Coq resource!).</p>")) ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-11-10-quicksort-in-coq.scrbl" . unix) f post (u . "Quicksort in Coq") (? . 4) 1442277678 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2014/11/10/quicksort-in-coq/index.html" . unix) "/blog/2014/11/10/quicksort-in-coq/" (u . "2014-11-10T09:01:16") (? . 2) (? . 3) (c (u . "Coq") c (u . "Dependent Types")) (u . "\n<p>Coq&rsquo;s support for dependent types mean that type checking not only\ncatches trivial errors like passing an integer to a function expecting\na string, but it can also check and verify types which represent\nproperties regarding the functional behavior of the a program.</p>\n\n<p>I thought it would be edifying to use this capability to write a\nverified version of quicksort (i.e. a quicksort with types that\nspecify its behavior), and it was!</p>") #t (u . "\n<p>Coq&rsquo;s support for dependent types mean that type checking not only\ncatches trivial errors like passing an integer to a function expecting\na string, but it can also check and verify types which represent\nproperties regarding the functional behavior of the a program.</p>\n\n<p>I thought it would be edifying to use this capability to write a\nverified version of quicksort (i.e. a quicksort with types that\nspecify its behavior), and it was!</p>\n<!--more-->\n\n<h1><a name=\"(part._.Basic_.Quicksort)\"></a>Basic Quicksort</h1>\n\n<p>So first let&rsquo;s just write quicksort, and then we&rsquo;ll see\nwhat dependent types can add.</p>\n\n<h2><a name=\"(part._.A_.First_.Attempt)\"></a>A First Attempt</h2>\n\n<p>This was my initial attempt at writing quicksort in Coq (first w/o the\nmore complex types):</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Fixpoint</span> <span class=\"n\">quicksort</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">gtb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"k\">in</span>\n      <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">++</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"k\">end</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Looked pretty good, I thought! It was nice and simple... until I tried\nto compile it:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">Error</span><span class=\"o\">:</span>\n<span class=\"nc\">Recursive</span> <span class=\"n\">definition</span> <span class=\"k\">of</span> <span class=\"n\">quicksort</span> <span class=\"k\">is</span> <span class=\"n\">ill</span><span class=\"o\">-</span><span class=\"n\">formed</span><span class=\"o\">.</span>\n<span class=\"nc\">In</span> <span class=\"n\">environment</span>\n<span class=\"n\">quicksort</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span>\n<span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n<span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span>\n<span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span>\n<span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span>\n<span class=\"nc\">Recursive</span> <span class=\"n\">call</span> <span class=\"n\">to</span> <span class=\"n\">quicksort</span> <span class=\"n\">has</span> <span class=\"n\">principal</span> <span class=\"n\">argument</span>\n<span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"s2\">\"lhs\"</span> <span class=\"n\">instead</span> <span class=\"k\">of</span> <span class=\"s2\">\"xs\"</span><span class=\"o\">...</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Of course - my recursive calls are not structurally recursive\n(i.e. they&rsquo;re not on the structural pieces that make up the input),\nso Coq isn&rsquo;t convinced our recursive calls will terminate.</p>\n\n<blockquote class=\"refpara\">\n <blockquote class=\"refcolumn\">\n  <blockquote class=\"refcontent\">\n   <p>Coq requires all programs to be total and deterministic\nto ensure its logic is sound.</p></blockquote></blockquote></blockquote>\n\n<h2><a name=\"(part._.Guaranteeing_.Termination)\"></a>Guaranteeing Termination</h2>\n\n<p>Doing a little digging, I discover that one way to write\nfunctions which Coq cannot infer termination for is\nusing the keywords \"Program\" and \"measure\":</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">Program</span> <span class=\"kn\">Fixpoint</span> <span class=\"n\">quicksort</span>\n      <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n      <span class=\"o\">{</span><span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n<span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">=&gt;</span> <span class=\"n\">nil</span>\n<span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">leb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">++</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Now Coq knows that the decreasing argument to be measured is the\nlength of the input (from {measure (length l)}), and it knows that I\nam... \"Program\"-ing... err... I mean it may also generate\n<span style=\"font-style: italic\">proof obligations</span> from this fixpoint definition (which is what\nProgram specifies).</p>\n\n<p>Okay, so I compiled it and then I got some new messages (woohoo!).</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"n\">quicksort</span> <span class=\"n\">has</span> <span class=\"n\">type</span><span class=\"o\">-</span><span class=\"n\">checked</span><span class=\"o\">,</span> <span class=\"n\">generating</span> <span class=\"mi\">3</span> <span class=\"n\">obligation</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"nc\">Solving</span> <span class=\"n\">obligations</span> <span class=\"n\">automatically</span><span class=\"o\">...</span>\n<span class=\"n\">quicksort_obligation_3</span> <span class=\"k\">is</span> <span class=\"n\">defined</span>\n<span class=\"mi\">2</span> <span class=\"n\">obligations</span> <span class=\"n\">remaining</span>\n<span class=\"nc\">Obligation</span> <span class=\"mi\">1</span> <span class=\"k\">of</span> <span class=\"n\">quicksort</span><span class=\"o\">:</span>\n<span class=\"k\">forall</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">l0</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">length</span> <span class=\"n\">l0</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span>\n<span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n<span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span>\n<span class=\"k\">let</span> <span class=\"n\">filtered_var</span> <span class=\"o\">:=</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">leb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"k\">in</span>\n<span class=\"k\">forall</span> <span class=\"n\">rhs</span> <span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">=</span> <span class=\"n\">filtered_var</span> <span class=\"o\">-&gt;</span>\n                 <span class=\"n\">length</span> <span class=\"n\">lhs</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">.</span>\n\n<span class=\"nc\">Obligation</span> <span class=\"mi\">2</span> <span class=\"k\">of</span> <span class=\"n\">quicksort</span><span class=\"o\">:</span>\n<span class=\"k\">forall</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span>\n<span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">l0</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">length</span> <span class=\"n\">l0</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span>\n<span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n<span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">-&gt;</span>\n<span class=\"k\">let</span> <span class=\"n\">filtered_var</span> <span class=\"o\">:=</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">leb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"k\">in</span>\n<span class=\"k\">forall</span> <span class=\"n\">rhs</span> <span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">=</span> <span class=\"n\">filtered_var</span> <span class=\"o\">-&gt;</span>\n                 <span class=\"n\">length</span> <span class=\"n\">rhs</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Cool - two obligations. To solve these (which just verify the length\nof the inputs to the recursive calls (lhs and rhs) are &lt;= the length\nof the original input) I used \"Next Obligation of quicksort.\" twice,\napplying a little theorem proving where needed. After proving both, I\ngot:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">No</span> <span class=\"n\">more</span> <span class=\"n\">obligations</span> <span class=\"n\">remaining</span>\n<span class=\"n\">quicksort</span> <span class=\"k\">is</span> <span class=\"n\">defined</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Side note: You may have noticed I swapped out the \"let\" statement in the\noriginal attempt for a \"match\" statement - but why? Well, using the\n\"let\" left me proving the facts about lhs and rhs without any evidence\nas to where they came from. Match, on the other hand, gave me the\nassumption \"(lhs, rhs) = partition (gtb x) xs\", which was important\nsince that fact was key to proving their size was less than the\noriginal input. Kind of lame that I couldn&rsquo;t use the let (it seemed\nmore direct and elegant), but oh well.</p>\n\n<h1><a name=\"(part._.Verified_.Quicksort)\"></a>Verified Quicksort</h1>\n\n<p>So writing quicksort wasn&rsquo;t too bad. I learned a little about how\nproof obligations work with respect to the termination of\nfixpoints. But what about verifying it actually sorts the list we&rsquo;ve\ngiven it? How do we know it is correct?</p>\n\n<h2><a name=\"(part._.Is_testing_good_enough_)\"></a>Is testing good enough?</h2>\n\n<p>I could throw a few tests cases at it to feel a little better\nabout its correctness:</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">Example</span> <span class=\"n\">qs_nil</span><span class=\"o\">:</span>\n  <span class=\"n\">quicksort</span> <span class=\"bp\">[]</span> <span class=\"o\">=</span> <span class=\"bp\">[]</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">auto</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Example</span> <span class=\"n\">qs_ex1</span><span class=\"o\">:</span>\n  <span class=\"n\">quicksort</span> <span class=\"o\">[</span><span class=\"mi\">3</span> <span class=\"o\">;</span> <span class=\"mi\">2</span> <span class=\"o\">;</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">[</span><span class=\"mi\">1</span> <span class=\"o\">;</span> <span class=\"mi\">2</span> <span class=\"o\">;</span> <span class=\"mi\">3</span><span class=\"o\">].</span>\n<span class=\"kn\">Proof</span> <span class=\"k\">with</span> <span class=\"k\">auto</span><span class=\"o\">.</span>\n  <span class=\"k\">compute</span><span class=\"o\">...</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>But we still can&rsquo;t be 100% certain it is correct. In fact, in this case\na list reverse would have passed these tests! So in general, what\ncan we do if we want to <span style=\"font-style: italic\">formally verify</span> a program?\nIn a language like Coq there are multiple ways to do this!</p>\n\n<h2><a name=\"(part._.Proving_.Quicksort_.Correct_with_.Dependent_.Types)\"></a>Proving Quicksort Correct with Dependent Types</h2>\n\n<p>There&rsquo;s two primary approaches to verifying functions in Coq:\nYou can write a theorem stating quicksort is correct and\nprove it valid, or you can add the specification to the type\nof quicksort itself. Let&rsquo;s do the latter.</p>\n\n<div class=\"brush: coq\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"nc\">Program</span> <span class=\"kn\">Fixpoint</span> <span class=\"n\">quicksort</span>\n      <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"kt\">list</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n      <span class=\"o\">{</span><span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n      <span class=\"o\">{</span><span class=\"n\">sl</span> <span class=\"o\">:</span> <span class=\"kt\">list</span> <span class=\"n\">nat</span> <span class=\"o\">|</span>\n        <span class=\"nc\">Permutation</span> <span class=\"n\">l</span> <span class=\"n\">sl</span>\n        <span class=\"o\">/\\</span> <span class=\"nc\">StronglySorted</span> <span class=\"n\">le</span> <span class=\"n\">sl</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n<span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">=&gt;</span> <span class=\"n\">nil</span>\n<span class=\"o\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"o\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">gtb</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"o\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"o\">++</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">quicksort</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span><span class=\"o\">.</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>This approach looks like our original version, except that our return\ntype is not merely a list of nat, but a list of nat such that it is a\npermutation of the original and it is sorted (yes, that is all in the\nreturn type). Obligations for the predicate portion of the return type\n(Permutation l sl /\\ StronglySorted le sl) must be proven as well if\nCoq cannot automatically prove them (and in this case, it cannot).</p>\n\n<p>The first obligation related to the return type is for the empty list\ncase (nil), which is trivial (since quicksort merely returns nil,\nwhich is a permutation of nil and is sorted). In the second such\nobligation, we assume these properties hold for the recursive calls\n(quicksort lhs) and (quicksort rhs) (that they produce sorted\npartitions of their input - this is our inductive hypothesis) and\nprove these properties are maintained by (quicksort lhs) ++ x ::\n(quicksort rhs). With the use of a few lemmas related to partitioning\nand appending sorted lists that are related (such as how our two are\nin this case) this isn&rsquo;t these properties aren&rsquo;t too bad to verify.</p>\n\n<p>Suggestions and comments always welcome =)</p>")) ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-12-20-let-aliasing-in-typed-racket.scrbl" . unix) f post (u . "Let-aliasing in Typed Racket") (? . 3) 1442261876 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2014/12/20/let-aliasing-in-typed-racket/index.html" . unix) "/blog/2014/12/20/let-aliasing-in-typed-racket/" (u . "2014-12-20T08:23:08") (? . 4) (? . 1) (c (u . "Typed Racket")) (u . "\n<p>Although Typed Racket (TR) <span style=\"font-style: italic\">can</span> currently typecheck a large number\nof common idioms found in Racket code, reasoning about direct and indirect\nusages of aliasing has escaped its grasp... until now!</p>") #t (u . "\n<p>Although Typed Racket (TR) <span style=\"font-style: italic\">can</span> currently typecheck a large number\nof common idioms found in Racket code, reasoning about direct and indirect\nusages of aliasing has escaped its grasp... until now!</p>\n<!--more-->\n\n<h1><a name=\"(part._.Motivation_for_.Aliasing)\"></a>Motivation for Aliasing</h1>\n\n<p>Typed Racket&rsquo;s use of logical propositions about types enables\nit to typecheck programs whose control flows don&rsquo;t neatly fit\nwithin the realm of what traditional type systems can check.</p>\n\n<p>Here, for example, the type checker recognizes the result of\n<span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span> has type-related implications, whether it\nevaluates to <span class=\"RktVal\">#t</span> or <span class=\"RktVal\">#f</span>:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">foo</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">Any</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">size</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"hspace\">&nbsp;</span><span class=\"RktVal\">42</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>\n\n<p>That&rsquo;s great&ndash;but if we introduce just a little indirection:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">foo-let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">Any-&gt;</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">foo-let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">y</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">y</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">42</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">does</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">not</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">typecheck</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">in</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">Racket</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">version</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">&lt;=</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">6.1.1</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktCmt\">=(</span><span class=\"RktMeta\"></span></td></tr></tbody></table></div>\n\n<p>We discover that, even though <span class=\"RktSym\">y</span> was bound to <span class=\"RktSym\">x</span>,\nthat information does not make it into the type-system.\nInstead, the only information that relates the two values is\n(more or less) the following three propositions:</p>\n\n<ul>\n <li>\n  <p><span class=\"RktSym\">y</span> is of type <span class=\"RktSym\">Any</span></p></li>\n <li>\n  <p>If <span class=\"RktSym\">y</span> evaluates to <span class=\"RktVal\">#f</span>, <span class=\"RktSym\">x</span>\n   is of type <span class=\"RktSym\">False</span>.</p></li>\n <li>\n  <p>If <span class=\"RktSym\">y</span> evaluates to a non-<span class=\"RktVal\">#f</span> value,\n   <span class=\"RktSym\">x</span> is not of type <span class=\"RktSym\">False</span>.</p></li></ul>\n\n<p>Now, you may be thinking <span class=\"RktSym\">foo-let</span> doesn&rsquo;t typecheck because\nno one should ever write such a silly program! However, many of Racket&rsquo;s\nuseful macros expand into code which requires just this sort of\ntype-based reasoning:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">foo-match</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">Any</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">foo-match</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">match</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">number?</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">42</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">does</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">not</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">typecheck</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">in</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">Racket</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">version</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">&lt;=</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">6.1.1</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">because</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">match</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">expands</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">into</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">program</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">utilizing</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">let-bindings</span><span class=\"RktMeta\"></span></td></tr></tbody></table></div>\n\n<p>It sure would be nice if we could get some of these seemingly simple\nprograms (and more!) to typecheck without a big refactoring of\nthe type system...</p>\n\n<h1><a name=\"(part._.A_slight_aside__.What_is_an_object_in_.T.R_)\"></a>A slight aside: What is an object in TR?</h1>\n\n<p>In the calculus which describes Typed Racket&rsquo;s type system, an &rsquo;object&rsquo;\nis a syntactic representation of an expression. If an expression\n&lsquo;has an object,&rsquo; then there is some pure syntactic representation\nfor the value it will evaluate to. Currently, objects can represent variables\nor accesses into immutable values such as <span class=\"RktSym\">cons</span> cells or\n<span class=\"RktSym\">structs</span>. For example:</p>\n\n<p></p>\n\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td>\n    <p><span style=\"font-weight: bold\">Racket Expression</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p><span style=\"font-weight: bold\">TR Object</span></p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktSym\">x</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p><span class=\"RktSym\">x</span></p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktSym\">random</span><span class=\"stt\"> </span><span class=\"RktVal\">100</span><span class=\"RktPn\">)</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p>No Object</p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktSym\">caar</span><span class=\"stt\"> </span><span class=\"RktSym\">p</span><span class=\"RktPn\">)</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktSym\">car</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">car</span><span class=\"stt\"> </span><span class=\"RktSym\">p</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">y</span><span class=\"RktPn\">)</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p><span class=\"RktSym\">y</span></p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktSym\">string-length</span><span class=\"stt\"> </span><span class=\"RktSym\">s</span><span class=\"RktPn\">)</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p>No Object</p></td></tr>\n  <tr>\n   <td>\n    <p><span class=\"RktPn\">(</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">y</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktVal\">42</span><span class=\"RktPn\">)</span></p></td>\n   <td>\n    <p><span class=\"hspace\">&nbsp;</span></p></td>\n   <td>\n    <p><span class=\"RktSym\">y</span></p></td></tr></tbody></table>\n\n<p>Basically, objects enable the type system derive the same\nlogical meaning from expressions like <span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span>\nor <span class=\"RktPn\">(</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"stt\"> </span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span>\nas it does from <span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span>.</p>\n\n<h1><a name=\"(part._.A_.Simple_.Solution__.Let-aliasing_.Objects)\"></a>A Simple Solution: Let-aliasing Objects</h1>\n\n<p>In desire to keep things simple and maintain compatibility with what\nTyped Racket already does so well, I decided to explore adding a simple\naliasing extension to the current type system.</p>\n\n<h2><a name=\"(part._.Let-aliasing_overview)\"></a>Let-aliasing overview</h2>\n\n<p>My goal was to implement the following changes:</p>\n\n<ul>\n <li>\n  <p>Add a function <span class=\"RktSym\">&#952;</span> to the type environment which\nmaps identifiers to objects. By default, <span class=\"RktSym\">&#952;</span> just\nmaps identifiers to themselves.</p></li>\n <li>\n  <p><span class=\"RktSym\">&#952;</span> is extended when a let-expression binds an expression\n with an object to a variable. This extension is only in effect\n while checking the body of that let-expression.</p></li>\n <li>\n  <p>When typechecking any variable expression,\n<span class=\"RktSym\">x</span>, pretend your considering the object <span class=\"RktSym\">o</span>\n(where <span class=\"RktSym\">o</span><span class=\"stt\"> </span><span class=\"RktSym\">=</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#952;</span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span>) instead.</p></li></ul>\n\n<p>So, for example, when typechecking the <span style=\"font-style: italic\">body</span> of the let-expression in\n<span class=\"RktSym\">foo-let</span>, we extend <span class=\"RktSym\">&#952;</span> with the mapping <span class=\"RktPn\">(</span><span class=\"RktSym\">y</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"stt\"> </span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span>\ninstead of adding the three propositions relating <span class=\"RktSym\">x</span> and <span class=\"RktSym\">y</span>\nwe saw earlier:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">foo-let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">Any-&gt;</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">foo-let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">y</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">&lt;-</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">we</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">extend</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">&#952;,</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">mapping</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">'y'</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">to</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">the</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">object</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">'x',</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">making</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">references</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">to</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">'y'</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">be</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">viewed</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">y</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">as</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">references</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">to</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">'x'</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">here</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">within</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">42</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">the</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">body</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">of</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">the</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">let</span><span class=\"RktMeta\"></span></td></tr></tbody></table></div>\n\n<h2><a name=\"(part._.Type_.Judgments)\"></a>Type Judgments</h2>\n\n<p>Another way to describe this change is to observe the changes to the\ntype judgments affecting let-expressions and variables.</p>\n\n<p>Here are the original typing judgments (in a PLT Redex-ish format)\nfrom &lsquo;Logical Types for Untyped Languages&rsquo; by Tobin-Hochstadt and\nFelleisen [<a href=\"http://dl.acm.org/citation.cfm?id=1863561\">ACM link</a>]</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">Proves</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#964;_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">------------------------</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktVal\">\"T-Var\"</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#964;_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-!</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">e_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#964;_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_0+</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_0-</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">o_0</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">where</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_2</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">cons</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#964;_0</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">Or</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-!</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_0+</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_0-</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">&#915;_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_2</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">e_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#964;_1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_1+</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#968;_1-</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">o_1</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">------------------------</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktVal\">\"T-Let\"</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">&#915;_1</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">x_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">e_0</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">e_1</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">&#964;_1</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">o_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">/</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_0</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">&#968;_1+</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">o_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">/</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_0</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">&#968;_1-</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">o_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">/</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_0</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">o_1</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">o_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">/</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x_0</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span></td></tr></tbody></table></div>\n\n<p>Where <span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"stt\"> </span><span class=\"RktSym\">&#915;</span><span class=\"stt\"> </span><span class=\"RktSym\">e</span><span class=\"stt\"> </span><span class=\"RktSym\">&#964;</span><span class=\"stt\"> </span><span class=\"RktSym\">&#968;</span><span class=\"stt\"> </span><span class=\"RktSym\">&#968;</span><span class=\"stt\"> </span><span class=\"RktSym\">o</span><span class=\"RktPn\">)</span> is a 5-place relation with the\nfollowing arguments:</p>\n\n<ul>\n <li>\n  <p><span class=\"RktSym\">&#915;</span> is the current type environment.</p></li>\n <li>\n  <p><span class=\"RktSym\">e</span> is the expression being typechecked.</p></li>\n <li>\n  <p><span class=\"RktSym\">&#964;</span> is the type of <span class=\"RktSym\">e</span>.</p></li>\n <li>\n  <p>The first <span class=\"RktSym\">&#968;</span> is what we learn if <span class=\"RktSym\">e</span> evaluates\nto be a non-<span class=\"RktVal\">#f</span> value.</p></li>\n <li>\n  <p>The second <span class=\"RktSym\">&#968;</span> is what we learn if <span class=\"RktSym\">e</span> evaluates\nto <span class=\"RktVal\">#f</span>.</p></li>\n <li>\n  <p><span class=\"RktSym\">o</span> is the object of <span class=\"RktSym\">e</span>.</p></li></ul>\n\n<p><span class=\"RktPn\">(</span><span class=\"RktSym\">Proves</span><span class=\"stt\"> </span><span class=\"RktSym\">&#915;</span><span class=\"stt\"> </span><span class=\"RktSym\">&#968;</span><span class=\"RktPn\">)</span> is a 2-place relation which holds when the\nenvironment of propositions <span class=\"RktSym\">&#915;</span> can prove the proposition <span class=\"RktSym\">&#968;</span>.</p>\n\n<p><span class=\"RktPn\">(</span><span class=\"RktSym\">x_1</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"stt\"> </span><span class=\"RktSym\">&#964;_1</span><span class=\"RktPn\">)</span> and <span class=\"RktPn\">(</span><span class=\"RktSym\">x_1</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-!</span></span><span class=\"stt\"> </span><span class=\"RktSym\">&#964;_1</span><span class=\"RktPn\">)</span> are propositions\nwhich mean <span class=\"RktSym\">x_1</span> is or is not of some type <span class=\"RktSym\">&#964;_1</span>, respectively.</p>\n\n<p><span class=\"RktPn\">[</span><span class=\"RktSym\">o_0</span><span class=\"stt\"> </span><span class=\"RktSym\">/</span><span class=\"stt\"> </span><span class=\"RktSym\">x_0</span><span class=\"RktPn\">]</span> placed next to something means to\nsubstitute <span class=\"RktSym\">o_0</span> for <span class=\"RktSym\">x_0</span> within that something.</p>\n\n<p>Here are the let-aliasing versions that replace those rules (note we add\na place for <span class=\"RktSym\">&#952;</span> next to <span class=\"RktSym\">&#915;</span>):</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">where</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_x</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">lookup</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">Proves</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">o_x</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">------------------------</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">\"T-Var-Alias\"</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">o_x</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-!</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">o_x</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\">&#160;</span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_0</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">where</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">#f</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">equal?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">null</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">where</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_2</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">extend</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_0</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_2</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_2</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_1</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">------------------------</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">\"T-Let-Alias\"</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_0</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_1</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\">&#160;</span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">this</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">one</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">is</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">the</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">same</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">as</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">T-Let</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">above</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">but</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">e_0</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">is</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">required</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">to</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">have</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">null</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">object</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">(i.e.</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">not</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">have</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">an</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">object)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">null</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">where</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_2</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">cons</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_0</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">Or</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-!</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0+</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">And</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">False</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_0-</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_2</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_1</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\"><span class=\"nobreak\">------------------------</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">\"T-Let-No-Alias\"</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">TypeOf</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#952;_1</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#915;_1</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">x_0</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_0</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">e_1</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#964;_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">null</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">/</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1+</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">null</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">/</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">&#968;_1-</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">null</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">/</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">o_1</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">null</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">/</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x_1</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr></tbody></table></div>\n\n<p>This simple approach allows the type system to seamlessly track let-aliasing\nby only slightly modifying the type system&rsquo;s behavior for let-expressions\nand variables!</p>\n\n<p>With this change, TR can now successfully typecheck a variety of new programs!</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">super-foo</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">Any</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">super-foo</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">match</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">number?</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">`</span><span class=\"RktPn\">(</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktMeta\">.</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktMeta\">.</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">,</span><span class=\"RktPn\">(</span><span class=\"RktSym\">?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">number?</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">cddr</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">`</span><span class=\"RktPn\">(</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktMeta\">.</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktMeta\">.</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">,</span><span class=\"RktPn\">(</span><span class=\"RktSym\">?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">pair?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">p</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">if</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">caddr</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">(</span><span class=\"RktSym\">car</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktSym\">p</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">41</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktPn\">[</span><span class=\"RktSym\">_</span><span class=\"RktMeta\"></span><span class=\"hspace\">&nbsp;</span><span class=\"RktMeta\"></span><span class=\"RktVal\">42</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktMeta\"></span></td></tr>\n   <tr>\n    <td><span class=\"RktMeta\"></span><span class=\"RktCmt\">;;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">typechecks</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">with</span><span class=\"hspace\">&nbsp;</span><span class=\"RktCmt\">let-aliasing!</span><span class=\"RktMeta\"></span></td></tr></tbody></table></div>\n\n<p>Additionally, because this approach prevents several propositions from being\ngenerated (and disjunctions no less!) some programs which took quite a while\nto typecheck can now be verified immediately!</p>\n\n<h1><a name=\"(part._.Epilogue)\"></a>Epilogue</h1>\n\n<h2><a name=\"(part._.So_isn_t_this_just_copy_propagation_)\"></a>So isn&rsquo;t this just copy propagation?</h2>\n\n<p>It&rsquo;s definitely similar &#8212;\n <wbr /> both reason about known equalities between\nexpressions and have to be aware of mutation (our use of objects handles this)\n &#8212;\n <wbr /> however, we&rsquo;re not modifying the source program as a separate pass. We&rsquo;re keeping\nthe same program and just trying to edify the typechecker (without adding additional\npasses) with the same kinds of insights it could have if it was typehecking a\nprogram that had been rewritten using copy propagation or a similar technique.</p>\n\n<h2><a name=\"(part._.Are_there_any_simple_programs_you_re_still_working_to_typecheck_)\"></a>Are there any simple programs you&rsquo;re still working to typecheck?</h2>\n\n<p>Sure! This simple guy doesn&rsquo;t typecheck:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">size</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">(</span><span class=\"RktSym\">U</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">Number</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">String</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">size</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">match</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">number?</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">_</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">string-length</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>\n\n<p>Because it expands into something like this:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">size-expanded</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">let*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">x1</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">f2</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&#955;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">string-length</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">if</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">number?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">x1</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktSym\">x</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">f2</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>\n\n<p>Let-aliasing almost gets us there, but the environment in which <span class=\"RktSym\">f2</span>\nis typechecked doesn&rsquo;t know that we&rsquo;re only going to call it if <span class=\"RktSym\">x1</span>\nis not a number =(</p>\n\n<p>Perhaps this is an argument for why let-aliasing should be a little more like\ncopy propagation...? We&rsquo;ll have to do some more digging and find out!</p>\n\n<h2><a name=\"(part._.So_how_much_of_the_.Typed_.Racket_codebase_had_to_change_to_support_this_)\"></a>So how much of the Typed Racket codebase had to change to support this?</h2>\n\n<p>Not that much! <a href=\"https://github.com/racket/typed-racket/pull/2\">Here&rsquo;s</a> the Github pull request.</p>\n\n<p>I had to improve TR&rsquo;s ability to update type information inside of\nstructured types a little (e.g. <span class=\"RktSym\">cons</span> cells, <span class=\"RktSym\">struct</span>s) since\nwe no longer had extra variables floating around when we did things\nlike  <span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">x</span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">car</span><span class=\"stt\"> </span><span class=\"RktSym\">p</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"stt\"> </span><span class=\"RktSym\">...</span><span class=\"RktPn\">)</span>.</p>\n\n<p>Now when two propositions like <span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">Pairof</span><span class=\"stt\"> </span><span class=\"RktSym\">Number</span><span class=\"stt\"> </span><span class=\"RktSym\">Any</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span> and\n<span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">Pairof</span><span class=\"stt\"> </span><span class=\"RktSym\">Any</span><span class=\"stt\"> </span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span> are joined, we structurally recur into\nthe <span class=\"RktSym\">car</span> and <span class=\"RktSym\">cdr</span> of the type and get the resulting fact\n<span class=\"RktPn\">(</span><span class=\"RktSym\">x</span><span class=\"stt\"> </span><span class=\"RktSym\"><span class=\"nobreak\">-:</span></span><span class=\"stt\"> </span><span class=\"RktPn\">(</span><span class=\"RktSym\">Pairof</span><span class=\"stt\"> </span><span class=\"RktSym\">Number</span><span class=\"stt\"> </span><span class=\"RktSym\">Number</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span>, which was essential to typechecking\nprograms which use aliases instead of new variables.</p>\n\n<p>These changes were fairly natural/minor, however, and probably should have been\nmade at some point even without aliasing. Aliasing just brought the matter\nfront and center.</p>\n\n<p>Edits: A few typos</p>\n\n<h2><a name=\"(part._.Update__.What_if_.I_don_t_want_aliasing__)\"></a>Update: What if I don&rsquo;t want aliasing?!</h2>\n\n<p>This change, in addition to allowing aliasing, assumes it is the desired\ndefault behavior when typechecking. It was pointed out that with this change,\nthere are a few programs which <span style=\"font-style: italic\">used to</span> typecheck but no longer do:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">adhoc-min</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">All</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">adhoc-min</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">]</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">b*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">and</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">if</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&lt;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b*</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>\n\n<p>This program errors with the following message:\n<span style=\"font-style: italic\">Type Checker: type mismatch. Expected: A.\nGiven: (U Integer Inexact-Real) in: a*.</span></p>\n\n<p>This is because previously the absence of aliasing prevented occurrences of\n<span class=\"RktSym\">a*</span> or <span class=\"RktSym\">b*</span> from having their types updated by\ntype tests on <span class=\"RktSym\">a</span> or <span class=\"RktSym\">b</span>. If you wanted <span class=\"RktSym\">a*</span> or <span class=\"RktSym\">b*</span>\nto be unnaffected by type tests on <span class=\"RktSym\">a</span> or <span class=\"RktSym\">b</span>, you can simply\nadd explicit annotations at the <span class=\"RktSym\">let</span>-binding site:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">adhoc-min2</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">All</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">adhoc-min2</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">let</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktPn\">[</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">]</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">b*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">and</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">if</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&lt;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b*</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>\n\n<p>or use local <span class=\"RktSym\">define</span>s to create <span class=\"RktSym\">a*</span> and <span class=\"RktSym\">b*</span>:</p>\n\n<div class=\"SCodeFlow\">\n <table cellpadding=\"0\" cellspacing=\"0\" class=\"RktBlk\">\n  <tbody>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">:</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">adhoc-min3</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">All</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\"><span class=\"nobreak\">-&gt;</span></span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">A</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">adhoc-min3</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">define</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">cond</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktPn\">(</span><span class=\"RktSym\">and</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">integer?</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">if</span><span class=\"hspace\">&nbsp;</span><span class=\"RktPn\">(</span><span class=\"RktSym\">&lt;</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b</span><span class=\"RktPn\">)</span><span class=\"hspace\">&nbsp;&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">b*</span><span class=\"RktPn\">)</span><span class=\"RktPn\">]</span></td></tr>\n   <tr>\n    <td><span class=\"hspace\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"RktPn\">[</span><span class=\"RktSym\">else</span><span class=\"hspace\">&nbsp;</span><span class=\"RktSym\">a*</span><span class=\"RktPn\">]</span><span class=\"RktPn\">)</span><span class=\"RktPn\">)</span></td></tr></tbody></table></div>")) ((p+ #"/Users/amk/Repos/andmkent.github.io/_src/posts/2014-03-24-racket-to-c-examples.md" . unix) f post (u . "C to Racket Examples") (? . 2) 1442277274 (p+ #"/Users/amk/Repos/andmkent.github.io/blog/2014/03/24/c-to-racket-examples/index.html" . unix) "/blog/2014/03/24/c-to-racket-examples/" (u . "2014-03-24T09:16:07") (? . 5) (? . 4) (c (u . "Racket") c (u . "C")) (u . "\n<p>This post is a collection of simple C code snippets and roughly equivalent Racket code.</p>\n\n<p>Hopefully if you&rsquo;re coming from a C background (or similar) and you&rsquo;re struggling to make sense of Racket code, these examples will assist in clearing the fog.</p>") #t (u . "\n<p>This post is a collection of simple C code snippets and roughly equivalent Racket code.</p>\n\n<p>Hopefully if you&rsquo;re coming from a C background (or similar) and you&rsquo;re struggling to make sense of Racket code, these examples will assist in clearing the fog.</p>\n<!-- more-->\n\n<h3 id=\"more-details\">More details</h3>\n\n<p>If you wish for a more in depth introduction to Racket, I recommend perusing the excellent <a href=\"http://docs.racket-lang.org/guide/\">Racket Guide</a>. If you&rsquo;re curious about a particular function the <a href=\"http://docs.racket-lang.org/\">Racket manuals</a> are a great resource. If I&rsquo;ve configured the page correctly, library functions in the code snippets should link to their manual entries.</p>\n\n<br />\n\n<p><em>If your beginning your first venture into the world of  <a href=\"http://en.wikipedia.org/wiki/Functional_programming\">functional  programming</a>,  you&rsquo;ll want to do some reading to understand the norms of this world  vs. what&rsquo;s likely been ingrained into your being from years of  imperative programming (sorry I don&rsquo;t have a good reference for this  as I&rsquo;m writing this&hellip;)</em></p>\n\n<p><em>Also, neither the C nor the Racket code is meant to be the epitome  of elegance or ideal programming - they&rsquo;re merely there to  demonstrate how things might be expressed in each language.</em></p>\n\n<br />\n\n<h2 id=\"table-of-contents\">Table of Contents</h2>\n\n<ol>\n <li><a href=\"#preproc\">Preprocessor Commands</a></li>\n <li><a href=\"#variab\">Values and Variables</a></li>\n <li><a href=\"#arith\">Arithmetic</a></li>\n <li><a href=\"#struct\">Structures</a></li>\n <li><a href=\"#array\">Array Indexing</a></li>\n <li><a href=\"#scope\">Local/Scoped Definitions</a></li>\n <li><a href=\"#fun\">Functions and Conditionals</a></li>\n <li><a href=\"#rec\">Recursion</a></li>\n <li><a href=\"#list\">Lists and Loops</a></li>\n <li><a href=\"#other\">Other</a></li></ol>\n\n<br />\n\n<h2 id=\"preprocpreprocessor-stuff\"><a name=\"preproc\"></a>Preprocessor stuff</h2>\n\n<h4 id=\"c-includes\">C includes</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"cp\">#include &lt;stdio.h&gt;</span>\n<span class=\"cp\">#include &lt;stdlib.h&gt;</span>\n<span class=\"cp\">#include &lt;string.h&gt;</span>\n<span class=\"cp\">#include &lt;stdbool.h&gt;</span>\n<span class=\"cp\">#include &lt;math.h&gt;</span>\n<span class=\"cp\">#include &lt;ctype.h&gt;</span>\n<span class=\"cp\">#include &lt;assert.h&gt; </span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-lang-and-requires\">Racket #lang and requires</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kn\">#lang </span><span class=\"nn\">racket</span>\n<span class=\"c1\">; we&#39;ll just need the testing suite \"rackunit\"</span>\n<span class=\"c1\">; the rest is included in the default racket language</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))\" style=\"color: inherit\">require</a></span> <span class=\"n\">rackunit</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"variabvalues-and-variables\"><a name=\"variab\"></a>Values and Variables</h2>\n\n<h3 id=\"declaration-and-initialization\">Declaration and initialization</h3>\n\n<h4 id=\"c-data\">C data</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// true</span>\n<span class=\"kt\">int</span> <span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// false (only 0 is false)</span>\n<span class=\"kt\">int</span> <span class=\"n\">x</span>  <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"c1\">// int</span>\n<span class=\"kt\">int</span> <span class=\"n\">pi</span> <span class=\"o\">=</span> <span class=\"mf\">3.14</span><span class=\"p\">;</span> <span class=\"c1\">// float </span>\n<span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"p\">;</span> <span class=\"c1\">// char</span>\n<span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"s\">\"Hello World!\"</span><span class=\"p\">;</span> <span class=\"c1\">// string</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">fibs</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">};</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-data\">Racket data</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">b1</span> <span class=\"no\">#t</span><span class=\"p\">)</span> <span class=\"c1\">; true, #true is equivalent</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">b2</span> <span class=\"no\">#f</span><span class=\"p\">)</span> <span class=\"c1\">; false, #false is equivalent (the only false value)</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"c1\">; exact-integer</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((lib._racket/math..rkt)._pi))\" style=\"color: inherit\">pi</a></span> <span class=\"mf\">3.14</span><span class=\"p\">)</span> <span class=\"c1\">; flonum</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">c</span> <span class=\"sc\">#\\a</span><span class=\"p\">)</span> <span class=\"c1\">; character</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">str</span> <span class=\"s2\">\"Hello World!\"</span><span class=\"p\">)</span> <span class=\"c1\">; string</span>\n\n<span class=\"c1\">; singly linked list</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">fibslist</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"c1\">; fixed-length array with constant-time access</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">fibsvec</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/vectors.html#(def._((quote._~23~25kernel)._vector))\" style=\"color: inherit\">vector</a></span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Note: small note, by default Racket lists are immutable and vectors are mutable. Alternate versions of either are available as well (see docs).</p>\n\n<h3 id=\"assignment-mutation\">Assignment (Mutation)</h3>\n\n<h4 id=\"c-assignment-mutation\">C Assignment (Mutation)</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span> <span class=\"c1\">// initialization</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"c1\">// assignment/mutation</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-mutation\">Racket Mutation</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">x</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\">; initialization</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/set_.html#(form._((quote._~23~25kernel)._set!))\" style=\"color: inherit\">set!</a></span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"c1\">; mutation</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"aritharithmetic\"><a name=\"arith\"></a>Arithmetic</h2>\n\n<h4 id=\"c-math\">C math</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">6</span><span class=\"p\">);</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">4</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"mi\">3</span><span class=\"p\">))</span> <span class=\"o\">/</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-math\">Racket math</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">y</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))\" style=\"color: inherit\">+</a></span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">y</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">z</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._/))\" style=\"color: inherit\">/</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))\" style=\"color: inherit\">+</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n                <span class=\"mi\">4</span><span class=\"p\">)</span>\n             <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">z</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"structstructures\"><a name=\"struct\"></a>Structures</h2>\n\n<h3 id=\"structure-definitions\">Structure Definitions</h3>\n\n<h4 id=\"c-structs\">C structs</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-structs\">Racket structs</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._define-struct))\" style=\"color: inherit\">define-struct</a></span> <span class=\"n\">point</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"p\">))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>Note: small note, Racket structs are immutable by default. Mutable structs are available (see docs).</p>\n\n<h3 id=\"structure-usage\">Structure Usage</h3>\n\n<h4 id=\"c-struct-accessors\">C struct accessors</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">};</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">4</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-struct-accessors\">Racket struct accessors</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">p</span> <span class=\"p\">(</span><span class=\"n\">point</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">point-x</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">point-y</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"arrayconstant-time-array-access\"><a name=\"array\"></a>Constant-time array access</h2>\n\n<h4 id=\"c-array-indexing\">C array indexing</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"n\">fibs</span><span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">};</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">fibs</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-vector-ref\">Racket vector-ref</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">fibs</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/vectors.html#(def._((quote._~23~25kernel)._vector))\" style=\"color: inherit\">vector</a></span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/vectors.html#(def._((quote._~23~25kernel)._vector-ref))\" style=\"color: inherit\">vector-ref</a></span> <span class=\"n\">fibs</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h2 id=\"scopelocalscoped-definitions-blocks-and-lets\"><a name=\"scope\"></a>Local/Scoped Definitions (blocks and lets)</h2>\n\n<h4 id=\"c--blocks\">C {} blocks</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n    \n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n\n<span class=\"p\">{</span>\n   <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n   <span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n   <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">11</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-let-expressions\">Racket let expressions</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))\" style=\"color: inherit\">let</a></span> <span class=\"p\">([</span><span class=\"n\">x</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n  <span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">x</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let*))\" style=\"color: inherit\">let*</a></span> <span class=\"p\">([</span><span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n       <span class=\"p\">[</span><span class=\"n\">y</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))\" style=\"color: inherit\">+</a></span> <span class=\"n\">x</span> <span class=\"mi\">10</span><span class=\"p\">)])</span>\n  <span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">y</span> <span class=\"mi\">11</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"n\">x</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p><em>Note: let* allows definitions to reference identifiers previously declared in the list of let bindings</em></p>\n\n<br />\n\n<h2 id=\"funfunction-definitions\"><a name=\"fun\"></a>Function Definitions</h2>\n\n<h3 id=\"basic-functions\">Basic Functions</h3>\n\n<h4 id=\"c-simple-function\">C simple function</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"nf\">square</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">square</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">9</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-simple-function\">Racket simple function</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">square</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">square</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"mi\">9</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p><em>Note: C functions are a series of statements with some specified &ldquo;return&rdquo; statement that dictates what the function call evaluates to (except for void, but you get the idea). Racket functions are more like a mathematical expression that is merely simplified/evaluated to some value and that value is returned.</em></p>\n\n<h3 id=\"functions-that-require-in-order-execution\">Functions that <em>require</em> in order execution</h3>\n\n<h4 id=\"c-command-line-interaction\">C command line interaction</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"nf\">square_input</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">str</span><span class=\"p\">[</span><span class=\"mi\">50</span><span class=\"p\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\"> Enter input: \"</span><span class=\"p\">);</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">\"%[^</span><span class=\"se\">\\n</span><span class=\"s\">]+\"</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">);</span>\n\n    <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">atoi</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">num</span> <span class=\"o\">*</span> <span class=\"n\">num</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Enter number: 7</span>\n<span class=\"c1\">// 49</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-command-line-interaction--begin\">Racket command line interaction &amp; begin</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">square-input</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))\" style=\"color: inherit\">begin</a></span>\n    <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))\" style=\"color: inherit\">printf</a></span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\"> Enter number: \"</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">input</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/Reading.html#(def._((quote._~23~25kernel)._read))\" style=\"color: inherit\">read</a></span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">input</span> <span class=\"n\">input</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">; Enter number: 9</span>\n<span class=\"c1\">; 81</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h3 id=\"functions-with-conditional-control-flow\">Functions with Conditional Control Flow</h3>\n\n<h4 id=\"c-if-else\">C if-else</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8\n9</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"nf\">int_abs</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">int_abs</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">int_abs</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-if-else\">Racket if-else</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">int-abs</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))\" style=\"color: inherit\">if</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))\" style=\"color: inherit\">&lt;</a></span> <span class=\"n\">x</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"mi\">-1</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n      <span class=\"n\">x</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">int-abs</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">int-abs</span> <span class=\"mi\">-1</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-if-else-if-else-if\">C if-else-if-else-if&hellip;</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">// returns number of real roots that exist</span>\n<span class=\"kt\">int</span> <span class=\"nf\">real_quad_roots</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">float</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mf\">4.0</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">c</span><span class=\"p\">;</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">d</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">d</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// (2x+2)(x-5) = 2x^2 - 8x - 10</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">real_quad_roots</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"c1\">// (x-5)(x-5) = x^2 - 10x + 25</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">real_quad_roots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"c1\">// x^2 + 4   no roots</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">real_quad_roots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-if-else-if-else-ie-cond\">Racket if-else-if-else&hellip; <em>i.e.</em> cond</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))\" style=\"color: inherit\">let</a></span> <span class=\"p\">([</span><span class=\"n\">d</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))\" style=\"color: inherit\">-</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">b</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n              <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"mi\">4</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"p\">))])</span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._cond))\" style=\"color: inherit\">cond</a></span>\n      <span class=\"p\">[(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))\" style=\"color: inherit\">&lt;</a></span> <span class=\"n\">d</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n      <span class=\"p\">[(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3d))\" style=\"color: inherit\">=</a></span> <span class=\"n\">d</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n      <span class=\"p\">[</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._else))\" style=\"color: inherit\">else</a></span>    <span class=\"mi\">2</span><span class=\"p\">])))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots</span> <span class=\"mi\">2</span> <span class=\"mi\">-8</span> <span class=\"mi\">-10</span><span class=\"p\">)</span>\n              <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots</span> <span class=\"mi\">1</span> <span class=\"mi\">-10</span> <span class=\"mi\">25</span><span class=\"p\">)</span>\n              <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n              <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"c1\">; We can also use internal defines instead of a let:</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots2</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">d</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))\" style=\"color: inherit\">-</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">b</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n               <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"mi\">4</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"p\">)))</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._cond))\" style=\"color: inherit\">cond</a></span>\n    <span class=\"p\">[(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))\" style=\"color: inherit\">&lt;</a></span> <span class=\"n\">d</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">[(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3d))\" style=\"color: inherit\">=</a></span> <span class=\"n\">d</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"p\">[</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._else))\" style=\"color: inherit\">else</a></span>    <span class=\"mi\">2</span><span class=\"p\">]))</span>\n\n<span class=\"c1\">; defines inside functions act just like the let version above, and</span>\n<span class=\"c1\">; you can just stick them in there (they don&#39;t have to contain a \"body</span>\n<span class=\"c1\">; expression\" like a let)</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots2</span> <span class=\"mi\">2</span> <span class=\"mi\">-8</span> <span class=\"mi\">-10</span><span class=\"p\">)</span>\n              <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots2</span> <span class=\"mi\">1</span> <span class=\"mi\">-10</span> <span class=\"mi\">25</span><span class=\"p\">)</span>\n              <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">real-quad-roots2</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n              <span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-function-with-structs\">C function with structs</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">float</span> <span class=\"nf\">distance</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"o\">*</span><span class=\"n\">p1</span><span class=\"p\">,</span> \n               <span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"o\">*</span><span class=\"n\">p2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">dx</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">dy</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">y</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">sqrt</span><span class=\"p\">((</span><span class=\"n\">dx</span> <span class=\"o\">*</span> <span class=\"n\">dx</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">dy</span> <span class=\"o\">*</span> <span class=\"n\">dy</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">point</span> <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">};</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">distance</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">p2</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-function-with-structs\">Racket function with structs</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))\" style=\"color: inherit\">begin</a></span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._when))\" style=\"color: inherit\">when</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/booleans.html#(def._((quote._~23~25kernel)._not))\" style=\"color: inherit\">not</a></span> <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._and))\" style=\"color: inherit\">and</a></span> <span class=\"p\">(</span><span class=\"n\">point?</span> <span class=\"n\">p1</span><span class=\"p\">)</span> \n                    <span class=\"p\">(</span><span class=\"n\">point?</span> <span class=\"n\">p2</span><span class=\"p\">)))</span>\n      <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/exns.html#(def._((quote._~23~25kernel)._error))\" style=\"color: inherit\">error</a></span> <span class=\"o\">'</span><span class=\"ss\">distance</span> <span class=\"s2\">\"Error <a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))\" style=\"color: inherit\">-</a> invalid parameter\"</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))\" style=\"color: inherit\">let</a></span> <span class=\"p\">([</span><span class=\"n\">dx</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))\" style=\"color: inherit\">-</a></span> <span class=\"p\">(</span><span class=\"n\">point-x</span> <span class=\"n\">p1</span><span class=\"p\">)</span>\n                 <span class=\"p\">(</span><span class=\"n\">point-x</span> <span class=\"n\">p2</span><span class=\"p\">))]</span>\n          <span class=\"p\">[</span><span class=\"n\">dy</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))\" style=\"color: inherit\">-</a></span> <span class=\"p\">(</span><span class=\"n\">point-y</span> <span class=\"n\">p1</span><span class=\"p\">)</span>\n                 <span class=\"p\">(</span><span class=\"n\">point-y</span> <span class=\"n\">p2</span><span class=\"p\">))])</span>\n      <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._sqrt))\" style=\"color: inherit\">sqrt</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))\" style=\"color: inherit\">+</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">dx</span> <span class=\"n\">dx</span><span class=\"p\">)</span>\n               <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">dy</span> <span class=\"n\">dy</span><span class=\"p\">))))))</span>\n\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">p1</span> <span class=\"p\">(</span><span class=\"n\">point</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">p2</span> <span class=\"p\">(</span><span class=\"n\">point</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span><span class=\"p\">)</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"recrecursive-functions\"><a name=\"rec\"></a>Recursive Functions</h2>\n\n<h4 id=\"c-recursion\">C recursion</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8\n9</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">long</span> <span class=\"nf\">factorial_rec</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">return</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">120</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-recursion\">Racket recursion</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">factorial</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))\" style=\"color: inherit\">if</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/number-types.html#(def._((quote._~23~25kernel)._zero~3f))\" style=\"color: inherit\">zero?</a></span> <span class=\"n\">x</span><span class=\"p\">)</span>\n      <span class=\"mi\">1</span>\n      <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"n\">x</span> <span class=\"p\">(</span><span class=\"n\">factorial</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._sub1))\" style=\"color: inherit\">sub1</a></span> <span class=\"n\">x</span><span class=\"p\">)))))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">factorial</span> <span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"mi\">120</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-recursion-on-linked-lists\">C recursion on linked lists</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">// a non-empty linked list</span>\n<span class=\"c1\">// is an element (first) followed by</span>\n<span class=\"c1\">// a linked list (the rest)</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">first</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"n\">rest</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">length</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">node3</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">node2</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">node3</span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">node1</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">node2</span><span class=\"p\">};</span>\n\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">node1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">3</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-recursion-on-lists\">Racket recursion on lists</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">; Lists in Racket?</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">1</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">1</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">2</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">)))</span>\n<span class=\"c1\">; list is shorthand for lists built with cons</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))\" style=\"color: inherit\">first</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._rest))\" style=\"color: inherit\">rest</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">2</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._length))\" style=\"color: inherit\">length</a></span> <span class=\"n\">l</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._cond))\" style=\"color: inherit\">cond</a></span>\n    <span class=\"p\">[(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty~3f))\" style=\"color: inherit\">empty?</a></span> <span class=\"n\">l</span><span class=\"p\">)</span>\n     <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">[</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._else))\" style=\"color: inherit\">else</a></span>\n     <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._add1))\" style=\"color: inherit\">add1</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._length))\" style=\"color: inherit\">length</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._rest))\" style=\"color: inherit\">rest</a></span> <span class=\"n\">l</span><span class=\"p\">)))]))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._length))\" style=\"color: inherit\">length</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"mi\">4</span><span class=\"p\">))</span> \n              <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._length))\" style=\"color: inherit\">length</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"mi\">4</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">))))</span> \n              <span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<br />\n\n<h2 id=\"listlists-and-loops\"><a name=\"list\"></a>Lists and Loops</h2>\n\n<h4 id=\"c-recursive-list-building\">C recursive list building</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">// builds list 0 through (i-1) from back</span>\n<span class=\"c1\">// to front</span>\n<span class=\"cp\">#define make_range(n) range_loop(n, NULL)</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"nf\">range_loop</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">rest</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"p\">));</span>\n        <span class=\"n\">new</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">new</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"n\">rest</span><span class=\"p\">;</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">range_loop</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">new</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> \n    <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">rest</span><span class=\"p\">;</span>    \n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">make_range</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n<span class=\"c1\">// we verify (painfully) the list is indeed [0, 1, 2]</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-recursive-list-construction-using-a-let-loop\">Racket recursive list construction (using a &ldquo;let-loop&rdquo;)</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">; return list of numbers 0 to (n-1)</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/data/integer-set.html#(def._((lib._data/integer-set..rkt)._make-range))\" style=\"color: inherit\">make-range</a></span> <span class=\"n\">n</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))\" style=\"color: inherit\">let</a></span> <span class=\"n\">range-loop</span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"n\">n</span><span class=\"p\">]</span>\n                   <span class=\"p\">[</span><span class=\"n\">l</span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))\" style=\"color: inherit\">empty</a></span><span class=\"p\">])</span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))\" style=\"color: inherit\">if</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/number-types.html#(def._((quote._~23~25kernel)._positive~3f))\" style=\"color: inherit\">positive?</a></span> <span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"n\">range-loop</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._sub1))\" style=\"color: inherit\">sub1</a></span> <span class=\"n\">i</span><span class=\"p\">)</span>\n                    <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))\" style=\"color: inherit\">cons</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._sub1))\" style=\"color: inherit\">sub1</a></span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"n\">l</span><span class=\"p\">))</span>\n        <span class=\"n\">l</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/data/integer-set.html#(def._((lib._data/integer-set..rkt)._make-range))\" style=\"color: inherit\">make-range</a></span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n              <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-list-sum-with-loop\">C list sum with loop</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"nf\">listsum</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">+</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span><span class=\"p\">;</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// make_range from previous example</span>\n<span class=\"c1\">// builds list of 0 through (n-1)</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">listsum</span><span class=\"p\">(</span><span class=\"n\">make_range</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">6</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-list-sum-with-for-loop\">Racket list sum with for loop</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">listsum</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"n\">sum</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))\" style=\"color: inherit\">begin</a></span> <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for))\" style=\"color: inherit\">for</a></span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"n\">l</span><span class=\"p\">])</span>\n           <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/set_.html#(form._((quote._~23~25kernel)._set!))\" style=\"color: inherit\">set!</a></span> <span class=\"n\">sum</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))\" style=\"color: inherit\">+</a></span> <span class=\"n\">sum</span> <span class=\"n\">i</span><span class=\"p\">)))</span>\n         <span class=\"n\">sum</span><span class=\"p\">))</span>\n\n<span class=\"c1\">; make-range from previous example</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">listsum</span> <span class=\"p\">(</span><span class=\"n\"><a href=\"http://docs.racket-lang.org/data/integer-set.html#(def._((lib._data/integer-set..rkt)._make-range))\" style=\"color: inherit\">make-range</a></span> <span class=\"mi\">4</span><span class=\"p\">))</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-list-building-loop\">C list building loop</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"o\">*</span> <span class=\"nf\">n_evens</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">prev</span><span class=\"p\">;</span>\n    <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n        <span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">list</span><span class=\"p\">));</span>\n        <span class=\"n\">new</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">prev</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>\n            <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">new</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">n_evens</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span> <span class=\"c1\">// l = [0, 2, 4]</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"mi\">4</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-forlist-loop\">Racket for/list loop</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8\n9</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"c1\">; make-range is built into Racket, and is called just range:</span>\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._range))\" style=\"color: inherit\">range</a></span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n\n<span class=\"c1\">; Builds list of the first n even natural numbers</span>\n<span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">n-evens</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/list))\" style=\"color: inherit\">for/list</a></span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._range))\" style=\"color: inherit\">range</a></span> <span class=\"n\">n</span><span class=\"p\">)])</span>\n    <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))\" style=\"color: inherit\">*</a></span> <span class=\"mi\">2</span> <span class=\"n\">i</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">n-evens</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"c-loop-that-finds-max-integer\">C loop that finds max integer</h4>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"kt\">int</span> <span class=\"nf\">max_in_list</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"p\">;</span>\n\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">max</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span><span class=\"p\">)</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">first</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">;</span>\n\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">rest</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">max</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">l3</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">l2</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">99</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">l3</span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">list</span> <span class=\"n\">l1</span> <span class=\"o\">=</span> <span class=\"p\">{.</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"mi\">42</span><span class=\"p\">,</span> <span class=\"p\">.</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">l2</span><span class=\"p\">};</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">max_in_list</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">l1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">99</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h4 id=\"racket-forfold-loop-that-finds-max-integer\">Racket for/fold loop that finds max integer</h4>\n\n<div class=\"brush: racket\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))\" style=\"color: inherit\">define</a></span> <span class=\"p\">(</span><span class=\"n\">max-in-list</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/fold))\" style=\"color: inherit\">for/fold</a></span> <span class=\"p\">([</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._max))\" style=\"color: inherit\">max</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))\" style=\"color: inherit\">first</a></span> <span class=\"n\">l</span><span class=\"p\">)])</span> <span class=\"p\">([</span><span class=\"n\">i</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._rest))\" style=\"color: inherit\">rest</a></span> <span class=\"n\">l</span><span class=\"p\">)])</span>\n    <span class=\"p\">(</span><span class=\"k\"><a href=\"http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))\" style=\"color: inherit\">if</a></span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))\" style=\"color: inherit\">&lt;</a></span> <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._max))\" style=\"color: inherit\">max</a></span> <span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"n\">i</span>\n        <span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._max))\" style=\"color: inherit\">max</a></span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"n\">check-equal?</span> <span class=\"p\">(</span><span class=\"n\">max-in-list</span> <span class=\"p\">(</span><span class=\"nb\"><a href=\"http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))\" style=\"color: inherit\">list</a></span> <span class=\"mi\">42</span> <span class=\"mi\">99</span> <span class=\"mi\">12</span><span class=\"p\">))</span> <span class=\"mi\">99</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>"))))